## [골4] 겹치는 선분 (1689번)

[https://www.acmicpc.net/problem/1689]()

### 문제 유형

정렬, 스위핑, 그리디, 우선순위 큐

<br>

### 어려웠던 점 / 문제의 핵심

2가지 풀이 법이 존재한다.

우선 시작점이 빠른 순, 끝점이 빠른 순으로 좌표들을 정렬하는 것은 동일하다.

#### (1) 우선순위 큐 활용

최소 우선순위 큐에 제일 처음 좌표의 끝 점을 삽입한다. 그리고 선분 개수의 최댓값은 1로 초기화한다.

선분을 순회하면서 현재 선분의 시작 지점이 우선순위 큐의 제일 첫 번째 요소 이상인 동안 우선순위 큐에서 요소를 뽑는다.

왜냐하면 해당 선분과 우선순위 큐 맨 위에 있는 있는 선분이 겹치지 않기 때문이다. 그 후 현재 선분의 끝 점을 우선순위 큐에 넣고, 우선순위 큐 크기의 최댓값으로 선분 개수의 최댓값을 갱신한다.

#### (2) 배열 활용

크기가 2N으로 2배의 크기로 배열을 선언하고, `i`에 `(s, 1)`을 `i + N`에 `(e, -1)`을 넣는다.

이렇게 1, -1로 구분하는 이유는 시작 점에서 겹치는 부분에서는 더하고, 끝 점에서 겹치는 부분은 빼기 위함이다.

순회하면서 `cnt`에 1 혹은 -1을 더하면서 최댓값을 갱신하면 된다.

<br>

### 언어별 풀이 요약

| 언어    | 메모리    | 실행 시간(ms) | 시간복잡도  | 공간복잡도 | 풀이 시간 | 시도 횟수 | 해설 참고            |
| ------- | --------- | ------------- | ----------- | ---------- | --------- | --------- | -------------------- |
| Python  |           |               |             |            |           |           |                      |
| Java(1) | 329384 KB | 3112 ms       | O(N * logN) | O(N)       | 60분      | 1         | :white_large_square: |
| Java(2) | 377972 KB | 3684 ms       | O(2N)       | O(2N)      | 60분      | 2         | :white_check_mark:   |
| Kotlin  |           |               |             |            |           |           |                      |

<br>

### 예외(테스트) 케이스

```
```

