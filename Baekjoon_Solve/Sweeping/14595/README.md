## [골3] 동방 프로젝트 (Large) (14595번)

https://www.acmicpc.net/problem/14595

### 문제 유형

자료 구조, 스위핑, 분리 집합(오프라인 쿼리), 그리디, DP

<br>

### 어려웠던 점 / 문제의 핵심

이 문제를 예전에 처음 풀었을 때는 어려웠다.

그 당시 풀이는 `오프라인 쿼리 + 유니온 파인드` 풀이었고 이번에도 이 당시에 접근했던 방법이 생각나서 오프라인 쿼리 + 유니온 파인드로 접근하려 했으나, 생각해보니 우선순위 큐를 활용한 스위핑으로 간단하게 해결할 수 있는 문제였다.

쿼리의 수가 0일 때와 우선순위 큐로 스위핑을 하다가 마지막 남은 구간을 넣어주는 처리만 해주면 딱히 신경쓸만한 요소는 없다. 

(예전에 내가 메모해놓은 것을 봤는데, 이 문제 그리디로도 풀 수 있고 DP로도 풀 수 있단다. 사람들은 참 대단하다...)

#### 문제 풀이

- 스위핑을 위한 우선순위 큐를 선언하고, 시작 번호가 빠른 순, 끝 번호가 빠른 순으로 우선순위를 설정한다.
- M이 0이면 N을 출력하면 되고, 그렇지 않으면 M개의 쿼리에 대해 우선순위 큐에 시작 번호와 끝 번호 쌍을 담는다.
- 그 후 우선순위 큐의 맨 위에 있는 시작 번호와 끝 번호를 현재의 시작과 끝으로 설정한다.
- 우선순위 큐가 빌 때까지 시작 번호, 끝 번호 쌍을 뽑으면서
  - 시작 구간이 현재의 끝과 겹치는 부분이 있다면 현재의 끝을 더 큰 값으로 갱신한다.
  - 구간이 겹치는 부분이 없다면 현재의 시작과 끝을 리스트에 삽입하고, 현재의 시작과 끝을 현재 쌍의 정보로 갱신한다.
  - (중요) 만약 우선순위 큐가 비었다면, 현재의 구간을 새로운 쌍으로 만들어서 넣어준다. 왜냐하면 우선순위 큐가 비었기 때문에 더 이상 탐색을 하지 못해 이대로는 리스트에 현재의 구간을 반영한 정보를 넣지 못하기 때문이다.
- 남은 방의 수를 N으로 두고, 리스트를 순회하면서 남은 방의 수에서 (끝 번호 - 시작 번호) 값을 차감해준다.

<br>

### 언어별 풀이 요약

| 언어   | 메모리    | 실행 시간(ms) | 시간복잡도 | 공간복잡도 | 풀이 시간 | 시도 횟수 | 해설 참고            |
| ------ | --------- | ------------- | ---------- | ---------- | --------- | --------- | -------------------- |
| Python | 127372 KB | 1336 ms       | O(N + @)   | O(M + N)   | 70분      | 6         | :white_check_mark:   |
| Java   | 18640 KB  | 216 ms        | O(M)       | O(M)       | 30분      | 1         | :white_large_square: |
| Kotlin |           |               |            |            |           |           |                      |

<br>

### 예외(테스트) 케이스

```
```

