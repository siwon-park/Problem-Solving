## [실1] 선물할인 (25947번)

https://www.acmicpc.net/problem/25947

### 문제 유형

정렬, 그리디, 누적 합

<br>

### 어려웠던 점 / 문제의 핵심

누적 합과 그리디를 이용한 재미있는 문제였다.

단순 그리디로 풀면 올바른 답이 안 나올 것 같다. 왜냐하면 단순 그리디로 접근하면 가격을 오름차순 정렬 후 낮은 가격의 선물부터 계속 구매하다가 예산을 넘어가면 할인하는 방식을 취할 것 같은데, 반값 할인 시점이 해당 선물을 사는 순간이 아닐 수도 있다. 현재보다 더 이전일 수도 있다.

따라서 문제 접근을 단순 그리디가 아니라 누적 합 + 그리디로 현재 시점을 기준으로 탐색하여 답을 찾았다.

- 주어지는 선물의 가격을 오름차순으로 정렬한 다음, 원래 가격에 대한 누적 합 배열을 구한다.
  - 모든 선물 가격은 2 이상의 짝수로 주어지기 때문에 굳이 반값 누적 합 배열을 만들 필요가 없다.

- 그 후 배열을 역순으로 순회하여 만약 i개의 선물 누적 합이 예산보다 크면, i번 이하의 선물 a개를 반값 할인했을 때 구매가 가능한지 확인해본다.
  - i번 이하의 선물 a개를 반값 할인했을 때의 가격은 `(prefix[i] - prefix[i - a]) / 2`로 구할 수 있다.
  - 구매가 가능하다면 break하여 더 이상 탐색하지 않는다. 이 때가 할인해서 구매 가능한 선물의 최대 개수이기 때문이다.
- 할인 여부와 상관없이 i개의 선물 누적 합이 예산보다 작거나 같으면 break한다. 이 때가 이미 최대 갯수임이 보장되기 때문이다.

<br>

### 언어별 풀이 요약

| 언어   | 메모리   | 실행 시간(ms) | 시간복잡도 | 공간복잡도 | 풀이 시간 | 시도 횟수 | 해설 참고            |
| ------ | -------- | ------------- | ---------- | ---------- | --------- | --------- | -------------------- |
| Python |          |               |            |            |           |           |                      |
| Java   | 33812 KB | 488 ms        | O(N)       | O(N)       | 30분      | 2         | :white_large_square: |
| Kotlin |          |               |            |            |           |           |                      |

<br>

### 예외(테스트) 케이스

```
```

