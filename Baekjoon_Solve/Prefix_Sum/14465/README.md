## [실2] 소가 길을 건너간 이유 5 (14465번)

https://www.acmicpc.net/problem/14465

### 문제 유형

누적 합, 슬라이딩 윈도우, 투 포인터

<br>

### 어려웠던 점 / 문제의 핵심

문제 유형에 투 포인터는 없지만 누적 합 + 투 포인터로도 O(N)의 시간으로 풀 수 있을 것 같다.

사실 슬라이딩 윈도우로 풀면 정말 쉽게 푸는 문제이지만, 누적 합을 연습해보고 싶어서 누적 합으로 풀었다. 아이디어를 떠오르기까지 시간이 조금 걸렸다.

문제 아이디어 자체는 슬라이딩 윈도우랑 크게 다를 바가 없다. 사실 이 문제 자체가 어쩌면 그냥 슬라이딩 윈도우로 풀라고 하는 것이었을 수도 있다.

연속한 K개의 구간에 존재하는 고장난 신호등의 최소 갯수를 구하면 되는 문제이다.

고장난 신호등의 개수 누적 합을 계산한 다음 `prefix[n + K] - prefix[n]`의 값 중 최솟값을 구하면 된다.

구간 `[a, b]`의 구간 합을 계산할 때, `prefix[b] - prefix[a - 1]`인 것과 같은 방식이다.

슬라이딩 윈도우로 풀 경우에는 최초 K개의 구간에 대해 고장난 신호등 개수를 구한 다음에, 양 끝을 동시에 오른쪽으로 옮겨 가면서 현재 구간 내에 존재하는 고장난 신호등의 최솟값을 구하면 된다.

<br>

### 언어별 풀이 요약

| 언어   | 메모리   | 실행 시간(ms) | 시간복잡도 | 공간복잡도 | 풀이 시간 | 시도 횟수 | 해설 참고            |
| ------ | -------- | ------------- | ---------- | ---------- | --------- | --------- | -------------------- |
| Python |          |               |            |            |           |           |                      |
| Java   | 15320 KB | 160 ms        | O(N)       | O(N)       | 25분      | 1         | :white_large_square: |
| Kotlin |          |               |            |            |           |           |                      |

<br>

### 예외(테스트) 케이스

```
```

