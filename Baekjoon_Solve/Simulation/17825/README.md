## [골2] 주사위 윷놀이 (17825번)

[https://www.acmicpc.net/problem/17825]()

### 문제 유형

구현, 시뮬레이션, 브루트포스, 백트랙킹

<br>

### 어려웠던 점 / 문제의 핵심

아래 그림과 같이 노드 번호에 따른 연결 관계(다음 노드)와 점수를 기록한 배열을 구성한 다음에

10턴 동안의 말 4개에 대한 백트랙킹 시뮬레이션을 하면 된다.

노드를 아래 그림처럼 구성했다면, `5`, `10`, `15`번 노드가 이번 주사위를 던졌을 때의 최종 도착지라면 각각 `22`, `26`, `29`번 노드로 변경해주는 로직이 필요하다. 

![image](https://user-images.githubusercontent.com/93081720/231937871-8a2e3762-81b2-40a4-8484-65191916999f.png)

문제 로직 자체는 어렵지 않았으나, 아예 처음부터 각 점수 간으로 연결하려고 해서 굉장히 헤맸다.

또한 갔다가 만약에 최종 위치에 말이 있다면 다시 롤백하는 로직을 시뮬레이션으로 구현해야 하는 줄 알고 그 부분을 구현하려고 하다가, 시간 낭비를 조금 했다.

사실 이전 위치만 기록하고 갈 수 있는 경우에만 이동하면 되는 것이기 때문에, 따로 왔던 과정을 그대로 역순으로 밟아서 롤백하는 로직은 필요 없었다. (이전 위치를 기록해서 롤백하는 로직을 적용하면 된다.)

<br>

### 언어별 풀이 요약

| 언어   | 메모리   | 실행 시간(ms) | 시간복잡도 | 공간복잡도 | 풀이 시간 | 시도 횟수 | 해설 참고            |
| ------ | -------- | ------------- | ---------- | ---------- | --------- | --------- | -------------------- |
| Python |          |               |            |            |           |           |                      |
| Java   | 15132 KB | 164 ms        | O(4^10)    | O(1)       | 70분      | 1         | :white_large_square: |
| Kotlin |          |               |            |            |           |           |                      |

<br>

### 예외(테스트) 케이스

```
```

