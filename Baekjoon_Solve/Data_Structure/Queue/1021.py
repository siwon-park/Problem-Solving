# 회전하는 큐(1021번)
################################################################################################
    # 문제: https://www.acmicpc.net/problem/1021
    # 큐
    # 큐를 2개 사용해야하나, 어떻게 풀어야하나 고민을 잠깐 많이 했던 문제이다.
    # 큐를 슬라이싱을 통해 전체 복사하려 했는데 허용하지 않는 문법이었다. 예전에 전체 복사를 슬라이싱으로 했던 기억이 있는데 착각했나보다
    # 몇 번 고민하다가 잠시 뒤에 풀 수 있었는데, 생각해보니 오른쪽으로 돌리나, 왼쪽으로 돌리나 큐에서 해당 요소를 뽑을 때 큐의 모양은 결국 같다.
    # 그점을 착안한다면 왼쪽을 기준으로 뽑는다고 했을 때, 오른쪽으로 돌려서 뽑는 카운트 수는 (전체 큐의 길이 - 왼쪽으로 돌려서 뽑는 횟수 + 1)이다.
    # 그 후 왼쪽, 오른쪽 결과를 비교해서 더 작은 숫자를 합산하는 방식으로 계산하였다.
    # 생각하기까지 좀 걸려서 난이도가 있다고 생각했는데 실버 4수준이라 조금 놀랐다.
################################################################################################
import sys
from collections import deque
input = sys.stdin.readline

N, M = map(int, input().split())

order = list(map(int, input().split())) # 목표 순서로 뽑을 큐
min_cnt = 0

n = N
tq = deque(list(range(1, N + 1)))
for i in range(M):
    target = order[i]
    l_cnt = 0 # 왼쪽으로 이동하는 횟수
    r_cnt = n
    while tq:
        cur = tq.popleft()
        if cur == target:
            n -= 1
            break
        l_cnt += 1 # 왼쪽으로 이동한 횟수 증가
        tq.append(cur)
    min_cnt += min(l_cnt, abs(n - l_cnt + 1)) # 오른쪽으로 이동해서 제일 첫 칸으로 가려면 n - l_cnt + 1 칸 가야함
print(min_cnt)
