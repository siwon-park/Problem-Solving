## [플3] 트리와 쿼리 2 (13511번)

https://www.acmicpc.net/problem/13511

### 문제 유형

자료 구조, 트리, 최소 공통 조상, 희소 배열

<br>

### 어려웠던 점 / 문제의 핵심

희소 배열을 통해 LCA를 빠르게 구하여 주어지는 쿼리에 대한 답을 구하면 된다.

1번 쿼리는 `u → v`로 가는 경로 비용을 출력 해야 하므로, `u → lca → v`로 가는 경로의 길이를 구하면 된다.

- 단, 이 때 u나 v가 lca일 경우에는 `distance[u]`나 `distance[v]`에서 `distance[lca]`를 한 번만 빼면 된다.
- 두 노드 모두 lca가 아니라면 `distance[u] + distance[v] - 2 * distance[lca]`가 경로의 길이이다.

2번 쿼리는 `u → v`로 가는 경로 중 `k`번째 노드를 찾는 것인데, `u`도 포함해야 하기 때문에 사실상 `k - 1`번째 노드를 찾는 것이다.

이 때 필요한 것은 lca와 두 노드 간의 깊이 차이이다.

- 만약 `k`가 `depth[u] - depth[lca]`보다 작거나 같다면, `u`의 `k`번째 부모를 찾으면 된다. (lca를 찾는 과정과 동일하다)
- 만약 `k`가 `depth[u] - depth[lca]`보다 크다면, `k`에서 `depth[u] - depth[lca]`를 빼고, 다시 `depth[v] - depth[lca]`에서 `k`를 뺀 다음에 `v`의 `k`번째 부모를 찾으면 된다.

![image](https://github.com/siwon-park/Problem_Solving/assets/93081720/d602b886-6dd4-4724-b7dd-c5340b8a1b8e)

<br>

### 언어별 풀이 요약

| 언어   | 메모리    | 실행 시간(ms) | 시간복잡도 | 공간복잡도 | 풀이 시간 | 시도 횟수 | 해설 참고            |
| ------ | --------- | ------------- | ---------- | ---------- | --------- | --------- | -------------------- |
| Python |           |               |            |            |           |           |                      |
| Java   | 144692 KB | 1484 ms       | O(MlogN)   | O(N)       | 50분      | 1         | :white_large_square: |
| Kotlin |           |               |            |            |           |           |                      |

<br>

### 예외(테스트) 케이스

```
```

