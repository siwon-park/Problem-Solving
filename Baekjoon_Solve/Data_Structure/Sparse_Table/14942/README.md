## [플5] 개미 (14942번)

https://www.acmicpc.net/problem/14942

### 문제 유형

자료 구조, 그래프 이론, 그래프 탐색, 깊이 우선 탐색, 희소 배열

<br>

### 어려웠던 점 / 문제의 핵심

희소 배열의 개념을 익힐 수 있는 재미있는 문제.

희소 배열의 의미를 항상 기억해야 한다. 희소 배열은 `2 ^ k번째 부모(혹은 떨어진 값)`가 무엇인지 저장된 배열이다.

기존 LCA(최소 공통 조상) + 희소 배열 문제와는 다르게 `깊이`라는 개념이 없고, 대신에 `체력(길이)`라는 개념이 존재한다.

따라서 `길이 차이만큼 무조건 이동할 수 있는 것이 아니라 현재 남아있는 체력이 얼마냐에 따라 이동 유무가 갈린다.`

![image](https://github.com/siwon-park/Problem_Solving/assets/93081720/a0f2e520-832b-460d-ba88-399ff6427001)

#### 풀이

- 루트 노드에서 출발하여 각 노드까지의 거리를 구하면서, 희소 배열에 부모의 정보를 저장한다.
- 희소 배열의 값을 갱신한다.
- 현재 체력으로 갈 수 있는 노드 중 1번 노드와 가장 가까운 노드를 구한다.
  - 현재 체력이 0보다 큰 동안 반복
  - 순회 전 체력을 기록한다 → 순회 후에도 체력이 같아서 0 이하로 내려가지 않을 경우 무한 루프가 발생하기 때문에 무한 루프를 방지하기 위함임
  - 희소 배열의 두 번째 인덱스인 `LOG`의 길이만큼 반복한다. 즉, 현재 위치에서 `2 ^ i 번째 부모`와의 거리를 따져서 갈 수 있는지 판단한 다음에 해당 위치로 현재 노드를 옮기는 작업을 반복한다.
  - 이동 순서는 상관 없다. 어차피 `체력`이라는 개념이 있기 때문에 체력이 허락하는 한 1번째 부모든, 2번째 부모든, 4번째 부모든, 8번째 부모든 이동이 가능하다.
  - 이동이 가능할 경우에는 현재 체력에서 이동할 다음 노드까지 가는데 필요한 길이(체력)를 뺀다.
  - 다음 노드까지 가는데 드는 비용은 다음과 같다.
    - `n1 → n2로 가는 비용 = (1 → n2로 가는 비용) - (1 → n1으로 가는 비용)`이다.
    - 이게 가능한 이유는 n2에서 1로 가는 경로에 n1이 반드시 존재하기 때문이다.
- 중요! 반환하는 값은 `parent[a][0]`이 아니라 `a`이다.
  - 왜냐하면 현재 체력이 0보다 큰 동안에 최대한으로 갈 수 있는 곳이 `a`이고, 체력이 0보다 크더라도 다음 노드인 `parent[a][0]`까지는 갈 수 없을 수도 있기 때문에 `a`를 반환해야 한다.


<br>

### 언어별 풀이 요약

| 언어   | 메모리   | 실행 시간(ms) | 시간복잡도 | 공간복잡도 | 풀이 시간 | 시도 횟수 | 해설 참고            |
| ------ | -------- | ------------- | ---------- | ---------- | --------- | --------- | -------------------- |
| Python |          |               |            |            |           |           |                      |
| Java   | 78276 KB | 832 ms        | O(MlogN)   | O(N)       | 50분      | 1         | :white_large_square: |
| Kotlin |          |               |            |            |           |           |                      |

<br>

### 예외(테스트) 케이스

```
```

