## [플5] 조용히 완전히 영원히 (30512번)

https://www.acmicpc.net/problem/30512

### 문제 유형

자료 구조, 세그먼트 트리, 느리게 갱신되는 세그먼트 트리, 오프라인 쿼리

<br>

### 어려웠던 점 / 문제의 핵심

문제가 쉬운 편은 아니었던 것 같다.

쿼리를 통해 업데이트를 실행한 `이후`에 더 이상 값이 변경되지 않는 원소를 잊힌 원소라고 한다.

- 따라서 해당 쿼리를 수행했을 때 바뀌는 원소는 잊힌 원소가 아니다.
- 마지막 업데이트 이후에는 더 이상 쿼리도 없어 바뀔 원소가 없다. 따라서 마지막 업데이트 이후 더 이상 값이 변경되지 않는 잊힌 원소의 개수는 항상 N개이다.
- `i-잊힌 원소`는 `i < j`인  j번째 쿼리들을 수행했을 때 바뀐 원소들을 누적하여 N에서 뺀 개수이다. 

#### 시행착오

"임의의 두 양의 정수 i < j에 대해, 모든 i-잊힌 원소는 j-잊힌 원소이다"라는 단어 때문에 오프라인 쿼리의 개념을 사용하려다 보니 시간을 많이 투자했다.

변화해야 하는 값 x가 작을 수록, 쿼리 번호가 작을 수록 더 빠른 순서로 정렬한 다음에 쿼리를 처리하려 했다.

어차피 원소가 x값으로 최소로 갱신되고 나면 더 이상 변할 일이 없기 때문이다.

#### 올바른 풀이

느리게 갱신되는 세그먼트 트리를 활용한다. 쿼리는 정렬을 해도 되고 하지 않아도 되는데, 정렬 하지 않는 것이 더 빠르다. 갱신될 때 마지막으로 수행된 쿼리 번호만 잘 기록하면 굳이 정렬하지 않아도 된다.

트리 배열에는 구간의 최솟값과 몇 번째 쿼리로 해당 값이 변경되었는지 기록한다.

마찬가지로 lazy 배열에는 갱신할 최솟값과 몇 번째 쿼리인지에 대한 정보가 담겨 있다.

구간의 최솟값이 더 크다는 의미는 해당 구간에 갱신되어야 할 원소가 있다는 의미이다.

구간의 최솟값이 lazy의 최솟값보다 크면 값과 쿼리 번호를 갱신한다.

lazy 전달도 마찬가지로 자식 lazy 배열에 저장된 최솟값보다 현재 lazy 값이 더 작을 때만 lazy를 전달한다. 

<br>

### 언어별 풀이 요약

| 언어   | 메모리   | 실행 시간(ms) | 시간복잡도      | 공간복잡도 | 풀이 시간 | 시도 횟수 | 해설 참고            |
| ------ | -------- | ------------- | --------------- | ---------- | --------- | --------- | -------------------- |
| Python |          |               |                 |            |           |           |                      |
| Java   | 72856 KB | 928 ms        | O(N + Q + logN) | O(N * 4)   | 120분     | 2         | :white_large_square: |
| Kotlin |          |               |                 |            |           |           |                      |

<br>

### 예외(테스트) 케이스

```
10
10 5 6 9 2 4 7 1 8 3
3
5 8 1
7 10 1
2 4 3

# ans:
10 3 3 3 1 1 1 1 1 1
5 7 10
```

