## [플5] 버블 소트 (1517번)

https://www.acmicpc.net/problem/1517

### 문제 유형

자료 구조, 정렬, 세그먼트 트리, 분할 정복

<br>

### 어려웠던 점 / 문제의 핵심

주어진 수열을 버블 정렬(bubble sort) 했을 때, swap이 총 몇 번 발생했는지 찾는 문제이다.

![image](https://github.com/user-attachments/assets/e3d64ad5-e62e-4500-8a07-c39e32ebb08a)

swap 횟수는 버블 정렬을 특징(i < j, arr[i] < arr[j]이면 스왑)을 잘 생각해보면 몇 회인지 쉽게 계산할 수 있고, 이에 대한 규칙을 부여하면 위 그림과 같다.

그런데 결국 이 swap 횟수는 정렬한 수열과 원래 위치를 비교했을 때, 교차하는 선분의 개수를 구하는 것과 같다.

![image](https://github.com/user-attachments/assets/26ff9542-0c18-496d-93de-e2f5d51c0784)

왜냐하면 정렬될 위치가 결국 본인이 최종적으로 가야할 위치이고, 본인이 가야할 올바른 위치 앞에 있는 숫자들도 당연히 이동이 있어야 하고 그만큼 교차(스왑)가 있기 때문이다.

따라서 이 문제는 교차하는 선분의 개수를 구하는 문제와 같으며, arr[i] = (num, idx)로 구성하여 num이 빠른 순으로 정렬을 해준다.

그 후 세그먼트 트리를 구성하여 idx위치에 값을 1 업데이트 해주고(선분을 그었다는 의미), 구간 [idx + 1, N]의 합을 누적하여 답을 구하면 된다.

<br>

### 언어별 풀이 요약

| 언어   | 메모리   | 실행 시간(ms) | 시간복잡도 | 공간복잡도 | 풀이 시간 | 시도 횟수 | 해설 참고          |
| ------ | -------- | ------------- | ---------- | ---------- | --------- | --------- | ------------------ |
| Python |          |               |            |            |           |           |                    |
| Java   | 96408 KB | 1856 ms       | O(NlogN)   | O(N)       | 75분      | 1         | :white_check_mark: |
| Kotlin |          |               |            |            |           |           |                    |

<br>

### 예외(테스트) 케이스

```
```

