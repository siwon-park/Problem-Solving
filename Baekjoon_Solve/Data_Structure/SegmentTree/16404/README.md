## [플3] 주식회사 승범이네

https://www.acmicpc.net/problem/16404

### 문제 유형

자료 구조, 그래프 이론, 트리, 세그먼트 트리, 느리게 갱신되는 세그먼트 트리, 오일러 경로 테크닉

<br>

### 어려웠던 점 / 문제의 핵심

주어지는 `사수-부사수` 관계를 트리로 구성한 다음에, 해당 트리를 `전위 순회` 혹은 `후위 순회`한 결과를 저장함과 동시에 `해당 노드를 루트 노드로 하는 서브 트리의 마지막 노드 번호`를 기록한다.

이렇게 하면 트리의 방문 순서가 오름차순으로 구성되기 때문에 특정 구간을 업데이트 하거나, 구간의 값을 찾을 수 있게 된다.

이를 위해 `dfs`함수를 만들어서 전위 순회와 동시에 서브 트리의 마지막 노드 번호를 기록할 수 있게 한다.

그 후, 구간 합을 구할 수 있는 느리게 갱신되는 세그먼트 트리를 구성하면 된다.

1번 쿼리에 대해서는 `left`값은 해당 노드 번호의 전위 순회로 방문한 순서가 되고, `right`값은 해당 노드 번호를 루트로 하는 서브 트리의 마지막 노드 번호로 하여 쿼리를 계산하면 된다.

2번 쿼리인, 특정 직원의 잔고를 구하라는 쿼리는 세그먼트 트리의 구간 합을 구하는 쿼리로 간주하여 계산하면 된다.

어차피 `i`번 구간 ~ `i`번 구간의 합을 구하는 것이기 때문에 lazy만 잘 전달하면 되는 것이고, 일치하지 않는 구간의 값(합)은 `0`으로 반환하면 되기 때문이다.

![image](https://user-images.githubusercontent.com/93081720/236658975-a6cfb9f8-5b2f-406e-b7b2-e13f3cc38142.png)

<br>

### 언어별 풀이 요약

| 언어   | 메모리    | 실행 시간(ms) | 시간복잡도 | 공간복잡도 | 풀이 시간 | 시도 횟수 | 해설 참고            |
| ------ | --------- | ------------- | ---------- | ---------- | --------- | --------- | -------------------- |
| Python |           |               |            |            |           |           |                      |
| Java   | 100576 KB | 1000 ms       | O(MlogN)   | O(N*4)     | 75분      | 1         | :white_large_square: |
| Kotlin |           |               |            |            |           |           |                      |

<br>

### 예외(테스트) 케이스

```
```

