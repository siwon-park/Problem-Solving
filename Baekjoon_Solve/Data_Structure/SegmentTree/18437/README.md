## [플3] 회사 문화 5 (18437번)

[https://www.acmicpc.net/problem/18437]()

### 문제 유형

자료 구조, 트리, 세그먼트 트리, 느리게 갱신되는 세그먼트 트리, 깊이 우선 탐색

<br>

### 어려웠던 점 / 문제의 핵심

문제를 너무 어렵게 생각해서 많은 시간을 소비했다.

문제에서 주어진 쿼리는 다음과 같이 해석할 수 있다.

- `1 i`: i번 직원을 상사로 가지고 있는 모든 직원은 컴퓨터를 켠다.
  - 구간의 모든 노드 값들을 전부 1로 바꾼다.
- `2 i`: i번 직원을 상사로 가지고 있는 모든 직원은 컴퓨터를 끈다.
  - 구간의 모든 노드 값들을 전부 0으로 바꾼다.
- `3 i`: i번 직원을 상사로 가지고 있는 직원 중에서 컴퓨터가 켜져있는 사람의 수를 출력한다.
  - 구간의 합을 출력한다.

`즉, 1번, 2번 쿼리에 대해 현재 상태와는 아무 상관 없이 컴퓨터를 켜야하면 켜고, 꺼야하면 끈다. 현재 상태는 전혀 중요하지 않다.` 그리고 또한 몇 번 켜졌는가, 꺼졌는가도 중요하지 않다. lazy의 전달만 중요할 뿐 누적되는 값은 전혀 중요한 정보가 아니다.

```java
void lazyPropagation(int s, int e, int n) {
    if (lazy[n] != 0) {  // lazy가 1이면 켜고, lazy가 -1이면 끈다.
        tree[n] = (lazy[n] == 1) ? e - s + 1 : 0; // lazy가 1일 경우 구간의 개수를 계산.
        if (s != e) {
            lazy[n * 2] = lazy[n];
            lazy[n * 2 + 1] = lazy[n];
        }
        lazy[n] = 0;
    }
}
```

또한, 각 쿼리를 자세히 보면 `i번 직원을 상사로 가지고 있는 직원 중`이라고 했으므로 i번 직원에 대한 정보를 구간 합을 계산하거나, 컴퓨터를 켜고 끄고 하는 로직에 반영하지 않아야 하는데, 해당 내용은 매우 간단한 트릭이다.

해당 내용은 i번 직원을 상사로 가지고 있는 직원이라고 했으므로, i번 노드를 부모로 가지고 있는 `왼쪽 서브 트리`와 `오른쪽 서브 트리`를 업데이트 하거나 구간 합을 구해야 한다.

그런데 이는 사실 자세히 보면 왼쪽 서브 트리의 루트 노드는 i번 트리보다 딱 1크다.

즉, 구간을 업데이트 하거나 합을 구할 때 `구간 [i + 1, last]`에 대해서 계산해주면 된다. (`last`는 i번 노드를 루트로 하는 서브 트리의 노드 중 가장 마지막 번호)

<br>

### 언어별 풀이 요약

| 언어   | 메모리   | 실행 시간(ms) | 시간복잡도 | 공간복잡도 | 풀이 시간 | 시도 횟수 | 해설 참고          |
| ------ | -------- | ------------- | ---------- | ---------- | --------- | --------- | ------------------ |
| Python |          |               |            |            |           |           |                    |
| Java   | 84244 KB | 788 ms        | O(MlogN)   | O(N * 4)   | 80분 +    | 3         | :white_check_mark: |
| Kotlin |          |               |            |            |           |           |                    |

<br>

### 예외(테스트) 케이스

```
```

