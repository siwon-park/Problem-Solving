## [플3] 화려한 마을 (12895번)

https://www.acmicpc.net/problem/12895

### 문제 유형

자료 구조, 세그먼트 트리, 느리게 갱신되는 세그먼트 트리, 비트마스킹

<br>

### 어려웠던 점 / 문제의 핵심

i번째 색을 색칠했는지 유무는 i번째 비트가 1인지 아닌지로 판별할 수 있다.

x와 y 사이의 모든 집을 z번 색으로 칠하는 작업은 해당 구간을 `1 << (z - 1)`로 바꾸는 것과 같다.

x와 y 사이의 모든 집에 사용된 색깔의 수를 구하는 작업은 비트 `OR`연산을 통해 나온 결과에서 1인 비트의 수가 총 몇 개인지 세는 것과 같다.

즉, 정리하자면

- 업데이트 쿼리가 주어졌으면 해당 구간의 값을 z번째 비트가 1인 숫자로 바꾸는 것이다.
- 연산 결과를 출력하는 쿼리가 주어졌으면 해당 구간에 존재하는 모든 값을 `OR`연산한 결과에서 비트가 1인 것의 수를 세는 것이다.

T가 최대 30이므로 int형으로 해결할 수 있다.

#### 실수한 점

매우 초보적인 실수를 해서 다 풀어 놓고 이상한 데서 헤맸다.

초기에 색칠된 색의 번호는 1이기 때문에 세그먼트 트리를 초기화할 때 `s == e`면 `tree[n] = 1`로 초기화 해야 한다. 여기까지는 했다.

그런데 결국 우리가 가지고 있어야 하는 값은 구간의 값들을 `OR`연산한 세그먼트 트리이므로, 초기화 할 때에도 자식들을 `OR`연산한 값을 부모가 가지고 있어야 한다.

```java
void init(int s, int e, int n) {
    if (s == e) {
        tree[n] = 1;
        return;
    }
    int mid = (s + e) / 2;
    init(s, mid, n * 2);
    init(mid + 1, e, n * 2 + 1);
    tree[n] = tree[n * 2] | tree[n * 2 + 1]; // 부모 역시 OR연산한 값을 가지고 있어야 한다.
}
```

그렇지 않으면 초기에 바로 전체 구간에 대해 OR연산 결과를 반환하는 쿼리가 들어왔을 때 0을 반환하게 된다.

<br>

### 언어별 풀이 요약

| 언어   | 메모리   | 실행 시간(ms) | 시간복잡도 | 공간복잡도 | 풀이 시간 | 시도 횟수 | 해설 참고            |
| ------ | -------- | ------------- | ---------- | ---------- | --------- | --------- | -------------------- |
| Python |          |               |            |            |           |           |                      |
| Java   | 79748 KB | 932 ms        | O(MlogN)   | O(N * 4)   | 60분      | 4         | :white_large_square: |
| Kotlin |          |               |            |            |           |           |                      |

<br>

### 예외(테스트) 케이스

```
```

