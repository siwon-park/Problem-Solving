## [플3] XOR (12844번)

https://www.acmicpc.net/problem/12844

### 문제 유형

자료 구조, 세그먼트 트리, 느리게 갱신되는 세그먼트 트리

<br>

### 어려웠던 점 / 문제의 핵심

XOR 연산의 특징은 다음과 같다

- A `XOR` A = 0
- A `XOR` 0 = A

lazy 배열의 내용을 전달하는 방법이 특이한 세그먼트 트리 문제이다.

구간 [a, b]에 k를 XOR 연산한다고 했을 때, 구간 합을 구하는 세그먼트 트리처럼 매번 Lazy 배열의 결과를 전달해서는 안 된다.

정확히는 해도 소용이 크게 없는 게 어차피 짝수 개를 가진 구간에서는 XOR연산을 해봤자 똑같은 값에 대해 XOR 연산을 2번 하면 0이기 때문에 0과 XOR 연산을 하면 그대로이기 때문이다.

아래 그림을 예로 들면,

구간 [0, 2]에 k를 XOR연산하는 쿼리를 실행시켰을 때, 실질적으로 [0, 0], [1, 1], [2, 2]에 각각 k가 XOR 연산이 적용되어야 한다.

그러면 [0, 1]에는 `k ^ k`가 연산되어 올라가므로 이는 결과적으로 0과 XOR연산을 한 것과 같다.

즉, 구간 [0, 1]에 기록된 값과 0을 XOR연산 하면 그대로 구간 [0, 1]에 기록된 값이 나온다.

이제 [0, 2]를 계산하기 위해서는 [0, 1]과 [2, 2]의 값을 XOR연산하면 되는데, 여기서는 `0 ^ k`가 연산되어 올라가므로 결국 구간 [0, 2]에 기록된 값과 k를 XOR연산한 것과 같다.

![image](https://user-images.githubusercontent.com/93081720/235912141-6553e100-476b-496e-94c1-5d6a4ffe702c.png)

if (s == e)라는 조건문으로 리프 노드일 때만 `XOR`연산을 적용시키다 보니, 1번 쿼리에 대한 결과물이 제대로 나오지 않게 되어 자꾸 맞왜틀을 하였다.

구간이 짝수로 나눠 떨어지면 XOR 연산을 하지 않게 해야 하므로

```java
if ((e - s + 1) % 2 == 1) tree[n] ^= lazy[n];
```

으로 lazy 배열의 값을 전달해야 한다.

<br>

### 언어별 풀이 요약

| 언어   | 메모리    | 실행 시간(ms) | 시간복잡도 | 공간복잡도 | 풀이 시간 | 시도 횟수 | 해설 참고          |
| ------ | --------- | ------------- | ---------- | ---------- | --------- | --------- | ------------------ |
| Python |           |               |            |            |           |           |                    |
| Java   | 203832 KB | 1520 ms       | O(MlogN)   | O(N*4)     | 80분      | 5         | :white_check_mark: |
| Kotlin |           |               |            |            |           |           |                    |

<br>

### 예외(테스트) 케이스

```
```

