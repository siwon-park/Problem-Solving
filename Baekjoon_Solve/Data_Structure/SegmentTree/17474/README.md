## [다1] 수열과 쿼리 26 (17474번)

https://www.acmicpc.net/problem/17474

### 문제 유형

자료 구조, 세그먼트 트리, 느리게 갱신되는 세그먼트 트리

<br>

### 어려웠던 점 / 문제의 핵심

문제는 매우 간단하지만, 난이도는 그렇지 않다.

이 문제를 푸는 세 가지 핵심은 (1) 세그먼트 트리에 무엇을 저장할까, (2) 언제 업데이트를 할까, (3) lazy 갱신 방법이다

#### (1) 세그먼트 트리에 저장하는 정보

각 세그먼트 트리에는 현재 구간의 최댓값(max1), 차기 최댓값(max2), 구간의 합(sum), 구간의 최댓값의 개수(maxCnt)를 저장하고 있어야 한다.

- maxCnt를 저장하는 이유는 구간의 최댓값이 변경되었을 때 최댓값을 개수를 활용하여 구간의 합을 빠르게 계산하기 위함이다.
- 차기 최댓값(max2)를 구하는 방법이 중요한데, 두 자식 노드 중 max1 값으로 선택받지 못한 노드의 max1값과 max1값으로 선택받은 노드의 max2 값을 비교하여 더 큰 값을 선택한다.

#### (2) 업데이트 조건

이 문제에서는 max2의 존재가 매우 중요하다.

기본적으로 update할 x값이 max1보다 크거나 같으면 굳이 해당 구간을 업데이트 할 필요가 없다는 것은 쉽게 파악 가능하다.

그러나 구간 [l, r]이 범위를 만족한다고 해서 무조건 해당 구간에 x를 업데이트 해야할까? 이 때 범위를 만족한다고 해서 무조건 업데이트를 하면 아래와 같은 문제가 생긴다.

- 정상적으로 구간의 합계가 업데이트 되지 않음
  - 자식 노드에 x가 전파되고 나서야 정상적으로 부모 구간의 합계를 계산 가능함
  - 즉, 구간을 만족한다고 해서 단순히 lazy를 전파하고 반환하면 자식이 제대로 업데이트 되지 않아서 잘못된 합계를 계산하게 된다.
- max2 값도 정상적으로 업데이트 불가능
  - max2의 값은 차기 최댓값인데, 이는 두 자식 노드를 업데이트 해야만 나오는 값이다. 부모가 가지고 있는 max2 값만으로는 정확한 계산이 불가능하다.

따라서 구간을 만족하고 max2의 값이 업데이트할 x보다 작을 경우에만 업데이트 및 lazy 전파를 한다. 왜 그럴까?

- 리프 노드의 max2 값은 항상 음수로 설정되어 있다.
- 따라서 리프 노드까지 구간이 내려오면 항상 업데이트를 할 수밖에 없는 조건이 만들어진다.
- 인접한 두 개의 리프 노드를 업데이트 하고 나서 부모 노드의 정보를 올바르게 업데이트 할 수 있게 된다.
- 또한 부모 구간의 max2 값이 음수이면 두 자식의 최댓값이 같다는 의미이기 때문에 정확한 구간의 합을 굳이 자식을 업데이트 하지 않아도 계산할 수 있다.

#### (3) lazy 갱신 방법

lazy 갱신 방법은 생각보다 간단하다. 두 자식 노드의 최댓값 max1을 비교하여 같은지, 왼쪽이 더 큰지, 오른쪽이 더 큰지 비교하여 max1, max2, sum, maxCnt 값을 갱신해준다.

<br>

### 언어별 풀이 요약

| 언어   | 메모리    | 실행 시간(ms) | 시간복잡도 | 공간복잡도 | 풀이 시간 | 시도 횟수 | 해설 참고          |
| ------ | --------- | ------------- | ---------- | ---------- | --------- | --------- | ------------------ |
| Python |           |               |            |            |           |           |                    |
| Java   | 455676 KB | 3956 ms       | O(NlogN)   | O(N)       | 120분     | 1         | :white_check_mark: |
| Kotlin |           |               |            |            |           |           |                    |

<br>

### 예외(테스트) 케이스

```
2
2 5
3
1 1 2 1
2 1 2
3 1 2


2
4 5
5
1 1 2 3
2 1 2
3 1 2
1 1 2 1
2 1 2
```

