## [플2] JuQueen (10277번)

https://www.acmicpc.net/problem/10277

### 문제 유형

자료 구조, 세그먼트 트리, 느리게 갱신되는 세그먼트 트리

<br>

### 어려웠던 점 / 문제의 핵심

문제를 간단하게 해석하면 아래와 같다.

- `change X S`: 코어 `X`의 주파수를 `S`단계만큼 변경시킨다.
- `groupchange A B S`: 구간 `[A, B]`의 모든 코어의 주파수를 `S`단계만큼 변화시킨다.
- `state X`: 코어 `X`의 주파수를 출력한다.

중요한 점은 코어의 주파수를 변경시킬 때 한 단계씩 변경하기 때문에 그룹 내에 있는 어떠한 코어라도 최소 0에서 최대 N이 되면 변경을 멈춰야 한다.

따라서 구간의 최댓값과 최솟값을 저장하고 있다가, 변경 전의 값과 변경 후의 값을 비교해서 구간에 업데이트 쿼리를 날려주는 방식으로 구현해야 한다.

변경해야 하는 값을 `S`라고 했을 때,

- `구간의 최댓값 + S > 한계값`일 경우
  - 구간의 최댓값으로 가질 수 있는 값이 `한계값(N)`이기 때문에 `N - 구간의 최댓값`을 모든 구간(최솟값, 최댓값)에 더해준다.
- `구간의 최솟값 + S < 0`일 경우
  - 구간의 최솟값으로 가질 수 있는 값이 `0`이기 때문에 `구간의 최솟값`을 모든 구간에서 차감해준다.
- 위 2가지 경우가 아닐 경우 업데이트 쿼리를 날려서 값을 변경시키더라도 `0`이상 `N`이하이기 때문에 업데이트 쿼리를 날려주면 된다.

#### 내가 실수했던 점 - 1

업데이트 쿼리를 날리기 전과 비교한 뒤에 차이만큼 업데이트 쿼리를 날리는 방식이 아니라

아예 `lazy`를 전달할 때 차이값 만큼 전달하는 방식으로 구현하였다. 나머지는 문제가 없었는데, 특정 지점의 코어 주파수를 출력하는 쿼리에 대해서 함수 내에서는 의도했던 값이 출력되나, 최종적으로 리턴되는 값이 원하는 값이 나오지 않았다. (1시간 이상 고민했으나 원인을 못 찾음)

#### 내가 실수했던 점 - 2

코어의 수 `C`, 주파수의 최댓값 `N`, 쿼리의 수 `O`가 주어지는데,

세그먼트 트리를 선언하면서 크기를 설정할 때 `C`의 값을 넣어야 함에도 불구하고 `N`의 값을 무의식적으로 넣고 있었다.

<br>

### 언어별 풀이 요약

| 언어   | 메모리    | 실행 시간(ms) | 시간복잡도 | 공간복잡도 | 풀이 시간 | 시도 횟수 | 해설 참고          |
| ------ | --------- | ------------- | ---------- | ---------- | --------- | --------- | ------------------ |
| Python |           |               |            |            |           |           |                    |
| Java   | 835636 KB | 1644 ms       | O(MlogN)   | O(N * 4)   | 180분     | 4         | :white_check_mark: |
| Kotlin |           |               |            |            |           |           |                    |

<br>

### 예외(테스트) 케이스

```
```

