## [플1] 농장 관리 (5916번)

https://www.acmicpc.net/problem/5916

### 문제 유형

자료 구조, 트리, 세그먼트 트리, 느리게 갱신되는 세그먼트 트리, 최소 공통 조상, Heavy-Light Decomposition

<br>

### 어려웠던 점 / 문제의 핵심

오일러 경로 + 최소 공통 조상(LCA) + 세그먼트 트리로 문제를 해결하였다.

먼저 DFS 함수로 오일러 경로(In, Out)와 LCA를 구하기 위한 깊이 배열에 값을 구한다.

그 후, 구간 합을 가지고 있는 세그먼트 트리를 구성하여 입력으로 들어오는 쿼리에 대해 다음과 같이 해결한다.

- `P u v`: u번 농장과 v번 농장 사이의 경로에 존재하는 모든 도로에 나무를 심는다.
  - u와 v의 경로 사이에 존재하는 모든 도로라고 했으므로, u와 v의 lca를 구한다.
  - 오일러 경로 상 u번 노드를 포함하는 모든 구간에 대해 += 1을 update한다.
  - 오일러 경로 상 v번 노드를 포함하는 모든 구간에 대해 += 1을 update한다.
  - 오일러 경로 상 lca 노드를 포함하는 모든 구간에 대해 -= 2를 update한다.
  - lazy propagation을 쓰지 않고 구간 합을 업데이트 하는 방법 중 하나로
  - S[i] : 구간 업데이트 쿼리에 의해 배열 A의 [l, ~] 구간에 업데이트 된 일정한 값이라고 할 때,
  - 이제 [l, r]에 x라는 값을 일정하게 더하라는 명령이 들어오면, S[l]에 x를 더하고, S[r + 1]에 x를 빼면 구간 [l, r]에 일정하게 x라는 값을 더한 것과 같아지게 된다. 
- `Q u v`: u번 농장과 v번 농장 사이의 도로에 존재하는 나무의 개수를 출력한다.
  - 여기서 말하는 도로란 u와 v 사이에 존재하는 특정(specific)한 경로이다.
  - 이 경로에 존재하는 모든 나무를 찾기 위해서는 u와 v 중 더 좁은 구간을 포함하고 있는 노드를 선택하여 해당 노드에서 자식 노드를 포함하는 나무들의 총합
  - 즉, u(또는 v)와 서브 트리상 마지막 노드 번호를 포함하는 구간의 누적합을 출력하면 된다.

<br>

### 언어별 풀이 요약

| 언어   | 메모리    | 실행 시간(ms) | 시간복잡도 | 공간복잡도 | 풀이 시간 | 시도 횟수 | 해설 참고          |
| ------ | --------- | ------------- | ---------- | ---------- | --------- | --------- | ------------------ |
| Python |           |               |            |            |           |           |                    |
| Java   | 105924 KB | 948 ms        | O(MlogN)   | O(N * 4)   | 120분     | 1         | :white_check_mark: |
| Kotlin |           |               |            |            |           |           |                    |

<br>

### 예외(테스트) 케이스

```
```

