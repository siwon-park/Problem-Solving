## [플1] 수열과 쿼리 13 (13925번)

https://www.acmicpc.net/problem/13925

### 문제 유형

자료 구조, 세그먼트 트리, 느리게 갱신되는 세그먼트 트리

<br>

### 어려웠던 점 / 문제의 핵심

문제를 거의 3시간은 넘게 푼 듯한데, 결국 어디서 실수 했는지 몰라서 다른 사람의 풀이를 참고했다.

쿼리가 여러 종류이면서, 연산의 종류도 여러 가지이다.

단순 덧셈, 뺄셈 연산이었다면 큰 문제가 없었겠지만, 이 문제에서는 전체에 일정 값을 곱하거나, 전체를 일정 값으로 변경하거나, 전체에 일정 값을 더하는 연산이 존재한다.

구간 합을 구하는 것이 최종 목표이기 때문에 구간 합을 저장하고 있는 세그먼트 트리를 구하면 된다.

`tree[n]`을 구간 합이라고 했을 때 곱에 대한 lazy와 합 연산에 대한 lazy를 각 각 따로 계산해서 구간 합에 갱신하게 되면 문제가 생긴다.

`tree[n] * w1 + (e - s + 1) * w2`과 `w1 * (tree[n] + w2 * (e - s + 1))`의 연산 결과는 다르다.

즉, 곱과 합에 대한 lazy는 따로 가져가되, 연산은 매번 둘에 대해서 다 해줘야 한다.

구해야 하는 값의 산식은 다음과 같다. `tree[n] = tree[n] * lazy1 + (e - s + 1) * lazy2`

각 쿼리에 대해서는 다음과 같이 처리하면 된다.

- 기본적으로 lazy 값은 2개 가져간다.
  - 곱 lazy의 기본값은 `1`이고, 합 lazy의 기본값은 `0`이다. 따라서 lazy를 전달하고 나면 해당 값으로 변경시켜준다.
- 1번 쿼리: 구간의 값들에 `v`의 값을 추가한다.
  - 합 lazy에 `v`의 값을 누적한다.

- 2번 쿼리: 구간의 값들이 `v`의 값을 곱한다.
  - 곱 lazy와 합 lazy에 `v`값을 곱한다.
  - 합 lazy에도 `v`를 곱하는 이유는 구간에 `v`라는 값을 곱했으니, 합 lazy를 통해 구간 합을 계산할 때도 `v`값이 곱해진 상태여야 하기 때문이다.
- 3번 쿼리: 구간의 값들을 `v`로 바꾼다.
  - 합 lazy의 값을 `v`로 바꾼다.
  - 단, 구간의 모든 값들이 `v`가 되었기 때문에 곱 lazy의 값은 0으로 바꾼다.

#### 실수했던 점1

lazy 전달 과정에서 구현 상 실수가 있었다.

곱 lazy에는 곱 lazy만, 합 lazy에는 합 lazy만 전달하면 되는 줄 알았다.

그런데 생각해보면 자식의 합 lazy에 전달할 값이 남아 있다면, 부모의 곱 lazy의 값을 자식의 합 lazy의 값에 곱해줘야 한다.

왜냐하면 부모 구간에 `v`라는 일정 값이 곱해졌으면 그 자식 구간에도 `v`라는 일정 값이 곱해져야 하는데, 부모의 합 lazy에만 `v`를 곱한 다음에 자식의 합 lazy에 누적 연산하게 되면, 원래 있던 자식의 합 lazy에는 `v`만큼 곱해진 값으로 연산되지 않기 때문이다.

따라서 자식의 합 lazy에 전달할 값이 남아 있으면 부모의 곱 lazy 값을 곱해주고 부모의 합 lazy 값을 더해줘야 한다.

```java
void lazyPropagation(int s, int e, int n) {
    if (lazy[0][n] != 0 || lazy[1][n] != 0) {
        tree[n] = ((e - s + 1) * lazy[1][n] + lazy[0][n] * tree[n]) % MOD;
        if (s != e) {
            lazy[0][n * 2] = (lazy[0][n * 2] * lazy[0][n]) % MOD;
            lazy[0][n * 2 + 1] = (lazy[0][n * 2 + 1] * lazy[0][n]) % MOD;
            // 자식의 합 lazy에 전달할 값이 남아 있으면 부모의 곱 lazy 값을 곱함
            lazy[1][n * 2] = (lazy[1][n * 2] * lazy[0][n] + lazy[1][n]) % MOD;
            lazy[1][n * 2 + 1] = (lazy[1][n * 2 + 1] * lazy[0][n] + lazy[1][n]) % MOD;
        }
        lazy[0][n] = 1;
        lazy[1][n] = 0;
    }
}
```

#### 실수했던 점2

`MOD`값으로 나누기 때문에 `int`형을 넘어가지 않을 것이라고 생각했는데, `MOD`로 나누기 전의 연산 과정에서 `int`형을 넘을 수도 있기 때문에 `long`형으로 선언하여 계산해야 한다.

<br>

### 언어별 풀이 요약

| 언어   | 메모리   | 실행 시간(ms) | 시간복잡도 | 공간복잡도 | 풀이 시간 | 시도 횟수 | 해설 참고          |
| ------ | -------- | ------------- | ---------- | ---------- | --------- | --------- | ------------------ |
| Python |          |               |            |            |           |           |                    |
| Java   | 74848 KB | 1364 ms       | O(MlogN)   | O(N * 4)   | 180분     | 1         | :white_check_mark: |
| Kotlin |          |               |            |            |           |           |                    |

<br>

### 예외(테스트) 케이스

```
```

