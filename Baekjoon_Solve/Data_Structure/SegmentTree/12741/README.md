## [플4] 쓰담쓰담 (12741번)

https://www.acmicpc.net/problem/12741

### 문제 유형

자료 구조, 세그먼트 트리

<br>

### 어려웠던 점 / 문제의 핵심

문제에서 2 종류의 쿼리가 주어지는데,

- 1번 쿼리: 구간 [L, R]이 오름차순인지 아닌지 판별
- 2번 쿼리: L과 R에 있는 숫자를 교환 (자리 바꿈)

2번 쿼리는 배열의 값을 찾아서 update 연산을 2번 해준 다음 스왑하면 되기 때문에 간단하다. 

결국에는 특정 구간이 오름차순인지 판별하는 방법을 구현하는 것이 문제 풀이의 핵심이다.



특정 구간이 오름차순인지 여부를 판별하는 방법은 아래와 같다.

세그먼트 트리의 배열은 2차원으로 선언한다. {구간 배열의 가장 왼쪽 값, 구간 배열의 가장 오른쪽 값}을 의미한다.

또한 현재 구간이 오름차순인지 여부를 담고 있는 배열도 선언한다.

- 만약 구간 [s, e]에서 s == e이면 세그먼트 트리의 리프 노드이기 때문에 들어갈 숫자가 한 개이기 때문에 무조건 오름차순이다.
- 두 구간 [s1, e1]과 [s2, e2]를 합칠 때 두 구간 중 하나라도 오름차순이 아니면 합친 구간도 오름차순이 아니다.
- 만약에 둘 다 오름차순일 경우, 구간의 왼쪽, 오른쪽의 값 비교를 통해 진짜 오름차순인지 확인해야 한다.
- 왼쪽 구간 배열의 오른쪽 값과 오른쪽 구간 배열의 왼쪽 값을 비교했을 때 왼쪽 구간 배열의 오른쪽 값이 더 크면 오름차순이 아니다.
- 이 외에는 오름차순이다. 리프 노드에서부터 동일한 규칙으로 노드를 구성했기 때문에 오름차순이 성립할 수밖에 없다.



오름차순 여부를 판별하는 함수를 구현할 때 유의해야 할 점이 하나 있는데, 구간을 벗어나면 일단 무조건 오름차순이라고 반환한다.

그 후 두 구간 중 하나가 오름차순이 아니면 false를 반환하면 되지만, 둘 다 true일 경우에는 왼쪽 구간 또는 오른쪽 구간이 [L, R]의 범위를 벗어났는지도 고려해야 한다. 범위를 벗어났다면 반대 구간은 범위를 벗어나지 않았기 때문에 범위를 벗어나지 않은 구간의 오름차순 여부를 반환하면 된다.

만약 둘 다 범위 안이고 둘 다 오름차순이라고 한다면 구간의 왼쪽, 오른쪽 값 비교를 통해 진짜 오름차순인지 한 번 더 확인 해주는 작업이 필요하다.



<br>

### 언어별 풀이 요약

| 언어   | 메모리   | 실행 시간(ms) | 시간복잡도 | 공간복잡도 | 풀이 시간 | 시도 횟수 | 해설 참고            |
| ------ | -------- | ------------- | ---------- | ---------- | --------- | --------- | -------------------- |
| Python |          |               |            |            |           |           |                      |
| Java   | 72284 KB | 904 ms        | O(MlogN)   | O(N * 4)   | 60분      | 1         | :white_large_square: |
| Kotlin |          |               |            |            |           |           |                      |

<br>

### 예외(테스트) 케이스

```
```

