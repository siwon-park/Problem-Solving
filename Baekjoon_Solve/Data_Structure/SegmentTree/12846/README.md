## [플5] 무서운 아르바이트 (12846번)

https://www.acmicpc.net/problem/12846

### 문제 유형

자료 구조, 세그먼트 트리, 분할 정복, 스택

<br>

### 어려웠던 점 / 문제의 핵심

세그먼트 트리 + 분할 정복의 개념을 사용해야 한다. (어차피 세그먼트 트리 자체가 분할 정복의 개념에 포함되긴 한다.)

[히스토그램(1725번)](https://www.acmicpc.net/problem/1725)과 같은 유형의 문제이다.

`구간 [a, b]의 최솟값 * (b - a + 1)의 최댓값`을 찾는 문제이다.

구간의 최솟값의 `인덱스를 저장하고 있는 세그먼트 트리`를 구성한다.

최솟값이 아니라 인덱스로 저장하는 이유는 인덱스를 활용하여 분할 정복을 하기 위함이다.

세그먼트 트리를 초기화할 때, 인덱스를 저장하기 때문에 원본 배열의 대소 비교를 통해서 세그먼트 트리의 노드에 들어갈 적절한 인덱스를 정해줘야 한다.

- 예) arr[left] <= arr[right]이면, tree[n] = left (단, left = tree[n * 2], right = tree[n * 2 + 1])

그 후 세그먼트 트리에서 구간의 최솟값의 인덱스를 찾는 함수를 구현한다.

이 때, 범위가 맞지 않으면 -1을 반환하는데 왼쪽 인덱스가 -1이면 오른쪽 인덱스 값을, 오른쪽 인덱스 값이 -1이면 왼쪽 인덱스 값을 반환한다. 둘 다 -1인 경우는 절대로 존재하지 않는다. 왜냐하면 한쪽 구간이 조건을 벗어났으면 반대쪽은 반드시 만족하기 때문이다.

마지막으로 분할 정복을 통해 구간의 너비 최댓값을 찾는 함수를 구현한다.

- 재귀 호출 시 매번 구간의 최솟값의 인덱스를 찾는 함수를 호출하고
- 해당 최솟값 * 구간의 값을 계산하고, 왼쪽 및 오른쪽으로 분할이 가능할 경우 분할하여 재귀 호출한 다음 리턴 받은 값과 비교하여 최댓값을 계산한다.
  - 호출 및 호출 종료 조건은 범위가 올바른 범위인지만 체크하면 된다.

| 1단계                                                        | 2단계                                                        | 3단계                                                        |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| ![image](https://github.com/siwon-park/Problem-Solving/assets/93081720/754be911-ea7e-44ec-976a-c49d90d360d4) | ![image](https://github.com/siwon-park/Problem-Solving/assets/93081720/789adf23-7cb6-4e24-b265-b582944be4b1) | ![image](https://github.com/siwon-park/Problem-Solving/assets/93081720/042ac327-b49a-4f3c-8a6a-75ed1b686f81) |

<br>

### 언어별 풀이 요약

| 언어   | 메모리   | 실행 시간(ms) | 시간복잡도  | 공간복잡도 | 풀이 시간 | 시도 횟수 | 해설 참고          |
| ------ | -------- | ------------- | ----------- | ---------- | --------- | --------- | ------------------ |
| Python |          |               |             |            |           |           |                    |
| Java   | 28048 KB | 384 ms        | O(N + logN) | O(N * 4)   | 60분      | 1         | :white_check_mark: |
| Kotlin |          |               |             |            |           |           |                    |

<br>

### 예외(테스트) 케이스

```
```

