## [플3] 자동차 공장 (2820번)

https://www.acmicpc.net/problem/2820

### 문제 유형

자료 구조, 트리, 세그먼트 트리, 느리게 갱신되는 세그먼트 트리, 깊이 우선 탐색

<br>

### 어려웠던 점 / 문제의 핵심

오일러 경로를 만들고, 느리게 갱신되는 세그먼트 트리의 구간[l, r]을 업데이트 하고, 구간 [l, l]의 값을 출력하면 되는 일반적인 문제인 줄 알았으나...

`각 사원 번호별로 주어진 초기값이 있기 때문에, 이 초기값을 전위 순회 결과에 맞게 다시 재배치 하는 작업이 필요하다`

아래 그림을 예를 들면,

초기값은 `[1, 2, 3, 4, 5, 6, 7, 8]`이나, 전위 순회 순서는 `[1, 2, 3, 4, 5, 6, 8, 7]`이다.

즉 7번째 순서의 초기값은 8이 되어야 하고, 8번째 순서의 초기값은 7이 되어야 한다.

따라서 전위 순회 결과에 맞게 초기값을 알맞게 재배치 해주는 작업이 필요하다.

![image](https://github.com/siwon-park/Problem_Solving/assets/93081720/3589390a-75f1-4216-bdfd-22d4ac17cb31)

#### 실수했던 점

전위 순회 결과에 맞게 초기값을 재배치하는 과정에서 다음과 같은 실수를 저질렀다.

```java
int[] pay = new int[N + 1];
for (int i = 1; i < N + 1; i++) pay[i] = arr[preOrd[i]];
```

위의 코드는 i번째 노드의 값은 i번째 노드의 전위 순회 순서에 위치한 초기값이라는 의미다. 

완전히 반대로 코드를 짜고 있었다.

결국 우리가 찾고자 하는 탐색 범위의 순서는 전위 순회 결과에 근거하고 있기 때문에

재배치하는 초기값의 인덱스는 전위 순회 결과여야 한다.

따라서 올바른 답은 아래 코드와 같이 `i번째 노드의 전위 순회 순서의 초깃값은 i번 노드의 초기값`이라고 해야 한다.

```java
int[] pay = new int[N + 1];
for (int i = 1; i < N + 1; i++) pay[preOrd[i]] = arr[i];
```

또한 유의할 점은 N, M의 최댓값이 50만이고, 업데이트하는 값의 범위가 최대 1만이기 때문에 `int`형을 벗어난다. 따라서 return하는 결과값은 `long`이어야 한다.

<br>

### 언어별 풀이 요약

| 언어   | 메모리    | 실행 시간(ms) | 시간복잡도   | 공간복잡도 | 풀이 시간 | 시도 횟수 | 해설 참고            |
| ------ | --------- | ------------- | ------------ | ---------- | --------- | --------- | -------------------- |
| Python |           |               |              |            |           |           |                      |
| Java   | 388276 KB | 1964 ms       | O(N + MlogN) | O(N * 4)   | 60분      | 4         | :white_large_square: |
| Kotlin |           |               |              |            |           |           |                      |

<br>

### 예외(테스트) 케이스

```
# case 1
8 8
1
2 1
3 2
4 3
5 3
6 5
7 1
8 6
p 1 2
p 2 4
u 3
u 6
p 5 -2
u 6
u 7
u 8

# answer 1
9
12
10
9
12
```

