# 폴리오미노(1343번)
###############################################################################
    # 문제: https://www.acmicpc.net/problem/1343
    # 그리디 알고리즘
    # 사전순으로 빠른 결과를 반환해야하므로 "AAAA"를 채울 수 있으면 "AAAA"를 먼저 채우고, 그 다음 "BB"를 채우는 그리디 문제
    # 처음에 "."을 기준으로 split()을 해서 풀려고 했는데
    # "."이 연속적으로 나오는 부분에 대해서 어떻게 처리해야할 지 고민을 하다가 잘 안돼서 인덱스로 접근해서 해결하였다.
    # 자세한 풀이는 코드 참조
###############################################################################
import sys
input = sys.stdin.readline

S = input().rstrip()

# 사전 순 결과를 반환해야하므로 AAAA를 채울 수 있으면 AAAA를 먼저 채우고, 그 다음 BB를 채움
def fill_board(S):
    S += "Y" # 전부다 "."이거나 "X"이면 아래 코드에 의해 공백을 리턴하게 되므로 문자열 1개 추가
    last = S[0] # 연속적으로 나온 것 체크
    tmp = S[0]
    N = len(S)
    s = ""
    for i in range(1, N):
        if last != S[i]: # 연속적으로 나온 것과 다른게 나왔으면
            if last == "X": # 이전에 연속적으로 나온게 X라면 해당 길이 따라 처리
                n = len(tmp)
                if n % 2: # X의 개수가 2로 나눠지지 않으면 만들 수 없음
                    return -1
                if n == 2:
                    s += "BB"
                elif n >= 4:
                    s += "AAAA" * (n // 4) + "BB" * ((n % 4) // 2)
            else: # last == "."이었다면 tmp는 전부 "."이므로 그대로 붙임
                s += tmp
            tmp = S[i]
            last = S[i]
        else: # 계속 같은 게 나온다면 tmp에 붙여나감
            tmp += S[i]
    return s

print(fill_board(S))
