## [골4] 수 묶기 (1744번)

https://www.acmicpc.net/problem/1744

### 문제 유형

그리디, 정렬, 많은 조건 분기

<br>

### 어려웠던 점 / 문제의 핵심

처음에 N이 50이기 때문에 백트랙킹으로 풀 수 있을까 생각해봤는데, 그리디였다.

백트랙킹으로 풀었다면 인접한 두 수를 묶거나 묶지 않음으로 나눠서 최댓값을 찾을 생각이었다. 그런데 잘 생각해보니 수열의 크기 N 자체는 50으로 작지만, 생기는 경우의 수는 많기 때문에 시간 초과가 날 것이다.



왜 그리디인가 생각해봤더니, `수를 묶었을 때`와 `묶지 않았을 때` 중 어떤 것이 더 큰 것인지 선택하면 된다.

수를 묶었을 때는 두 수를 곱한 결과이고, 수를 묶지 않았을 때는 두 수를 더한 결과이다.

그리고 두 수의 연산 결과가 커지려면 음수는 음수(0포함)끼리 곱했을 때 더한 것보다 커지고, 양수는 한쪽이 1이 아닌 이상 곱했을 때가 더했을 때보다 커진다.

음수, 양수의 속성을 잘 생각해보면 0을 포함한 음수와 양수로 나눠서 연산하는 게 더 이득이다.

그러면 음수와 양수가 더했을 때 더 커지는 경우가 있지 않나요? 라는 반문이 생길 수도 있는데

- 음수는 음수끼리 곱하면 양수가 되고, 음수의 개수가 홀수라면 남은 음수가 1개 생길 수 있다.
- 양수는 양수끼리 곱하거나 더하면 양수가 되고, 양수의 개수가 홀수라면 남는 양수가 1개 생길 수 있다.
- 그러면 이 두 수는 음수쪽이 0이 아니라면, 곱하는 것보다 더하는 게 이득일 수도 있다.



그리고 매번 두 수끼리만 비교해도 되는 이유는 "수열의 모든 수는 단 한번만 묶거나, 아니면 묶지 않아야한다."고 했고, 양수, 음수로 나눠서 두 수끼리만 순차적으로 비교하는 것이 우리가 원하는 더 큰 결과를 찾기 위한 가장 최선의 방법이기 때문이다.

양수, 음수별로 두 수끼리 연산한 결과를 비교하여 더 큰 수를 더해주고, 두 수끼리 연산 후, 홀수여서 각각 남은 수 1개들은 정답에 더해주기만 하면 된다.

<br>

### 언어별 풀이 요약

| 언어   | 메모리   | 실행 시간(ms) | 시간복잡도 | 공간복잡도 | 풀이 시간 | 시도 횟수 | 해설 참고            |
| ------ | -------- | ------------- | ---------- | ---------- | --------- | --------- | -------------------- |
| Python |          |               |            |            |           |           |                      |
| Java   | 14272 KB | 128 ms        | O(2 * N)   | O(N)       | 30분      | 1         | :white_large_square: |
| Kotlin |          |               |            |            |           |           |                      |

<br>

### 예외(테스트) 케이스

```
```

