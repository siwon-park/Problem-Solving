## [골5] 센서 (2212번)

[https://www.acmicpc.net/problem/2212]()

### 문제 유형

그리디, 정렬

<br>

### 어려웠던 점 / 문제의 핵심

아이디어를 생각해내기 조금 어려운 그리디 문제인 것 같다. 애초에 그리디인줄 모르면 풀기 어려운 문제인 듯 하다.

풀이법은 다음과 같다.

- 센서의 거리를 배열에 담아 정렬한다. 그 후에 두 센서 간 차이를 다시 배열에 담아 정렬한다.
- 만약 건설 가능한 기지국 수 K가 N보다 크거나 같으면 거리 합은 0이다.
- 그게 아니라 N이 더 클 경우, 두 센서의 위치 차이가 많이 나는 K - 1개의 그룹을 빼면 K개의 그룹을 만들 수 있다. `K - 1개의 구분선을 긋는다고 생각하면 편하다.`

즉, 두 센서 간 거리 차이를 구한 다음에 가장 거리 차이가 많이 나는 K - 1개의 그룹 사이에 선을 그어서 K개의 그룹을 만든다고 보면 된다.

#### 예시

예제 2번의 경우 다음과 같이 그룹을 나눌 수 있다.

즉, 두 센서 간 차이가 많이 나는 2 2 3 3에 해당하는 값 차이가 나오면 그곳에 선을 그어서 그룹을 구분해준다고 생각하면 된다.

정확히 5개의 그룹으로 나눌 수 있고 정답은 7이다.

![image](https://github.com/siwon-park/Problem_Solving/assets/93081720/d198268e-343d-4744-836e-cc6cb2809027)

<br>

### 언어별 풀이 요약

| 언어   | 메모리   | 실행 시간(ms) | 시간복잡도 | 공간복잡도 | 풀이 시간 | 시도 횟수 | 해설 참고          |
| ------ | -------- | ------------- | ---------- | ---------- | --------- | --------- | ------------------ |
| Python | 30840 KB | 72 ms         | O(N)       | O(N)       | 40분      | 1         | :white_check_mark: |
| Java   | 17012 KB | 192 ms        | O(N)       | O(N)       | 40분      | 1         | :white_check_mark: |
| Kotlin |          |               |            |            |           |           |                    |

<br>

### 예외(테스트) 케이스

```
```

