## [골2] 확장 게임 (16920번)

[https://www.acmicpc.net/problem/16920]()

### 문제 유형

그래프 이론, 그래프 탐색, BFS

<br>

### 어려웠던 점 / 문제의 핵심

큐 배열을 만들고 각 플레이어별 큐를 관리하여 문제를 해결해야 한다.

#### 실수했던 점

`0 - 1 BFS`로 해결할 수 있을 줄 알고 문제를 접근하였으나, 잘못된 접근이었다.

- 일반 BFS로는 성을 확장할 수 있는 위치임에도 불구하고, 0 - 1 BFS로 접근할 경우에는 이미 방문 체크가 되어 있어 `S`(이동 가능한 칸 수) 이하임에도 불구하고 다음 칸으로 이동하여 탐색하지 못할 수도 있다.
- 이를 극복하기 위해 방문 배열을 만들고 더 최단 거리로 방문했다면 큐에 삽입하는 방식을 사용하였으나, 이 경우 쓸데없이 방문하게 되는 공간이 더 많아지기 때문에 배열의 크기가 크다면 시간 초과가 날 수 밖에 없다.
  - 보다 정확히 말하면, 이미 특정 플레이어가 확장할 수 있는 모든 공간을 확장했음에도 불구하고, 방문 배열 상 이동한 칸 수가 더 큰 곳이 있다면 더 짧은 거리로 갱신하기 위해서 큐에 삽입하여 추가적인 탐색을 계속하게 된다.
  - 즉, BFS의 특징인 먼저 방문한 곳이 가장 빠르게 방문한 곳이라는 특징을 살리지 못하게 된다. 어차피 이 문제는 최단 거리를 활용해야 하는 문제가 아니기 때문에 0 - 1 BFS이 최단 거리를 못 구한다는 의미가 아니라, 다만 사용하는 것이 부적절할뿐이다. 

#### 올바른 풀이

큐 배열을 만들고 각 플레이어별 이번 턴의 큐를 관리한다.

- flag 변수가 true인 동안 while 문을 반복한다. (기본값은 true)
- 플레이어의 숫자만큼 순회하면서 현재 플레이어의 현재 턴 큐와 현재 플레이어의 다음 턴 큐를 관리한다.
- 현재 플레이어의 현재 턴 큐에서 요소를 뽑아서, 다음 이동할 위치가 범위 안이고 빈 칸이면
- 해당 위치에 현재 플레이어의 번호를 마킹하고, 해당 플레이어의 성의 개수를 1 증가시킨다.
  - 만약 이동한 칸의 수 + 1이 현재 플레이어의 최대 이동 칸 수 이하일 경우엔 현재  플레이어의 현재 턴 큐의 뒤에 요소를 삽입한다.
  - 아니라면 다음 턴에 확장해야 하므로, 이동한 칸의 수를 0으로 초기화한 다음에 다음 턴 큐에 삽입한다.
- 현재 플레이어의 큐를 다음 턴 큐로 변경한다.
- flag 변수를 false로 변경한 뒤, 플레이어의 숫자만큼 순회한다.
- 만약 플레이어의 큐가 비어있지 않다면, flag 변수를 true로 토글링하고 break하여 계속 반복한다.
- 모든 플레이어에 대해 순회하였어도 flag 변수가 false라면 그대로 종료하면 된다.

<br>

### 언어별 풀이 요약

| 언어   | 메모리    | 실행 시간(ms) | 시간복잡도 | 공간복잡도 | 풀이 시간 | 시도 횟수 | 해설 참고          |
| ------ | --------- | ------------- | ---------- | ---------- | --------- | --------- | ------------------ |
| Python |           |               |            |            |           |           |                    |
| Java   | 105444 KB | 672 ms        | O(MN)      | O(MN)      | 70분      | 4         | :white_check_mark: |
| Kotlin |           |               |            |            |           |           |                    |

<br>

### 예외(테스트) 케이스

```
```

