## [골1] 치삼이의 징검다리 건너기 (18128번)

[https://www.acmicpc.net/problem/18128]()

### 문제 유형

그래프 이론, 그래프 탐색, 이분 탐색, BFS, 다익스트라

<br>

### 어려웠던 점 / 문제의 핵심

BFS + 이분 탐색(매개 변수 탐색)으로도 풀 수 있지만, BFS + 다익스트라로도 풀 수 있다.

나는 BFS + 다익스트라로 풀었다. 만약 BFS + 매개 변수 탐색으로 푼 다면, (1, 1)에서 (N, N)까지 가는데 가는 경로 중에 (i, j)에 기록된 물이 퍼진 시간 중 최댓값 중 최솟값을 찾아서 반환하면 된다.

BFS + 다익스트라로 풀 경우에도 이와 유사하다. 최소의 max_level을 들고 다니면서 최단 거리 테이블을 구하면 된다.

답을 구하지 못할 경우 -1을 출력해야 함을 유의하자.

먼저 BFS 탐색으로 각 칸 (i, j)에 물이 퍼진 최소 시간을 기록한다. 이 때, 탐색 종료 후 (1, 1)과 (N, N)은 0으로 초기화시켜주자. 왜냐하면 문제에서 출발 지점과 도착 지점은 물이 닿지 않아도 항상 갈 수 있다고 했기 때문이다.

그 후, 다익스트라로 (1, 1)에서 출발해서 (N, N)까지 가는데 지나가는 경로 상에서, 현재까지 지나온 최소 시간 중 최댓값과 BFS 탐색으로 얻은 다음 위치에 기록된 시간 중 큰 값을 취한 후, 해당 최댓값이 다음 이동할 최단 거리 테이블 상 위치의 최댓값보다 작다면 갱신하여 탐색을 계속한다.

즉, (1, 1)에서 출발해서 (N, N)으로 가는데 존재하는 숫자들의 최댓값 중 최솟값을 계속해서 가지고 가면서 탐색하는 것이다.

BFS는 상하좌우 4방향 탐색이고, 다익스트라는 상하좌우, 대각까지 8방향임을 유의해야 한다.

<br>

### 언어별 풀이 요약

| 언어   | 메모리    | 실행 시간(ms) | 시간복잡도                | 공간복잡도     | 풀이 시간 | 시도 횟수 | 해설 참고            |
| ------ | --------- | ------------- | ------------------------- | -------------- | --------- | --------- | -------------------- |
| Python |           |               |                           |                |           |           |                      |
| Java   | 113952 KB | 980 ms        | O(N ^ 2 + (N ^ 2 * logN)) | O(3 * (N ^ 2)) | 40분      | 1         | :white_large_square: |
| Kotlin |           |               |                           |                |           |           |                      |

<br>

### 예외(테스트) 케이스

```
```

