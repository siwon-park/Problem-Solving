## [골1] 열쇠 (9328번)

https://www.acmicpc.net/problem/9328

### 문제 유형

너비 우선 탐색, 그래프 이론, 그래프 탐색

<br>

### 어려웠던 점 / 문제의 핵심

얼핏 보면 비트 마스킹 + BFS 처럼 보이지만 열쇠의 개수가 최대 26개가 될 수 있어서 비트 마스킹으론 불가능하다. 왜냐하면 2 ^ 26 * 100 * 100의 경우를 전부 다 탐색해야 할 수도 있기 때문.

따라서 다른 관점에서 최적화가 필요한데, 그 아이디어가 상당히 재밌다.

**바로 원하는 특정 조건을 만족할 때까지 대기하는 개념이 들어가 있기 때문이다.**

`열쇠 배열을 선언하고 열쇠를 갖고 있는지 유무를 관리`한다. 해당 배열은 공통적으로 사용한다. 되돌아가는 경우를 고려하지 않느냐는 의견이 있을 수도 있는데, 어쨌든 열쇠를 획득하고 문을 열고 갈 수 있게만 해주면 되기 때문에 상관이 없다.

문제를 푸는 핵심 아이디어는 `큐와 큐 배열`을 선언하는 것이다.

큐는 일반적으로 BFS 탐색을 위해 사용하고 큐 배열은 열쇠, 문에 따라서 처리를 해주기 위해서 만들었다.

- 다음 위치가 일반적인 경우, 즉 `$(문서)`나 `.(빈 칸)`일 경우 큐에 삽입하고 방문체크 한 다음 계속 탐색한다.
- 다음 위치가 `문(대문자)`인 경우
  - 해당 문에 맞는 키를 가지고 있다면 큐에 삽입한다.
  - `해당 문에 맞는 키를 가지고 있지 않다면 큐에 삽입하지 말고 해당 키에 해당하는 인덱스의 큐 배열에 삽입한다.`
    - **즉, 문을 열 수 있는 키를 찾을 때까지 잠시 대기하는 것과 같다!**
- 다음 위치가 `열쇠(소문자)`인 경우
  - 방문 체크한 다음에 큐에 삽입한다.
    - 열쇠를 갖고 있든 없든 큐에 삽입해서 다음 위치로 이동하게 해야 함을 유의!
  - 획득하지 않았던 키면(처음 획득하는 키일 경우)
    - 해당 키를 획득했음을 체크하고
    - `해당 키에 해당하는 인덱스의 큐 배열에서 대기 중인 요소들을 전부 뽑아서 큐에 삽입한다.`

<br>

### 언어별 풀이 요약

| 언어   | 메모리   | 실행 시간(ms) | 시간복잡도 | 공간복잡도 | 풀이 시간 | 시도 횟수 | 해설 참고          |
| ------ | -------- | ------------- | ---------- | ---------- | --------- | --------- | ------------------ |
| Python |          |               |            |            |           |           |                    |
| Java   | 22704 KB | 268 ms        | O(MN)      | O(MN)      | 60분      | 3         | :white_check_mark: |
| Kotlin |          |               |            |            |           |           |                    |

<br>

### 예외(테스트) 케이스

다음 위치가 열쇠일 때, 해당 열쇠를 가지고 있는가에 대한 유무에 따라 다음 위치에 이동할 로직을 분기처리 해버리면 아래 케이스에서 잘못된 답을 출력할 수도 있다. 다음 위치가 열쇠일 경우 해당 열쇠를 갖고 있든 없든 다음 위치로는 무조건 가게 해야 한다.

내 경우에는 처음 획득하는 열쇠인 경우에는 바로 큐 배열에만 삽입했고, 이미 갖고 있는 열쇠의 경우에만 큐에 삽입하게 했는데, 이렇게 하면 `x`라는 열쇠를 획득했을 때 다음 위치인 `d`로 갈 수 없는 상황이 발생하고, 이게 나비 효과가 되어 `D`문을 열지 못하고 문서를 획득 못하게 되는 상황이 발생한다.

```
1
15 15
**$*.**********
****.*******$**
****B.$****b.**
$*****c*****.**
*C$.*****fD..**
*$*xd******.**$
$.C********A.**
**h********.AA.
***************
***.i**********
***.***.K$*****
*k.$$I.$*******
******.$..j***$
*******D*******
****$**F*******
za

answer: 12
```

