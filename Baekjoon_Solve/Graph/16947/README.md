## [골3] 서울 지하철 2호선 (16947번)

[https://www.acmicpc.net/problem/16947]()

### 문제 유형

그래프 이론, 그래프 탐색, BFS, DFS

<br>

### 어려웠던 점 / 문제의 핵심

사이클 정점들을 찾고, 각 노드별로 사이클 노드에 이르기까지의 거리를 구하는 문제이다.

#### 풀이1)

순환선이려면 시작 지점에서 출발해서 다시 자기 자신으로 돌아올 수 있어야 한다.

N *N 크기의 2차원의 방문배열을 사용해서 각 노드에서 출발하여 현재 노드가 사이클인지 DFS 탐색을 통해 찾는다. 그러면서 사이클 노드를 하나 찾으면 일단 기록해둔다.

그 후 BFS 탐색을 통해서 사이클 노드에서 출발해서 다른 노드까지의 거리를 구한다. 이 때, 다음 탐색 지점이 사이클 노드이면 거리는 0로 기록하고, 사이클 노드가 아니라면 d + 1로 기록한다.

이 풀이의 경우 `O(N^2)`이 걸리며, 메모리도 비효율적으로 많이 사용한다.

#### 풀이2)

사실 풀이1) 처럼 푼 이유는 순환선이 여러 개일 것이라고 생각해서 그랬다.

하지만 문제에서 정점과 간선이 모두 N개이기 때문에 순환선은 최대 1개 존재할 수밖에 없다.

순환선이 0개일 경우 간선의 수는 무조건 N - 1개이고, 순환선이 최소 2개이려면 간선은 최소 N + 1개가 있어야 하기 때문이다. 따라서 DFS를 한 번만 돌리는 것으로 문제를 접근할 수 있다.

DFS를 구현할 때, 다음 노드가 이미 방문했는데, 이전 노드가 아닐 경우에 그 노드는  사이클 노드이다.

따라서 그 노드를 사이클 노드의 출발점으로 기록하고 true를 리턴한다. 이 때 현재 노드는 다른 노드를 타고 왔는데 다음 노드가 사이클 노드이기 때문에 사이클에 포함되므로 현재 노드의 사이클 여부도 true로 표시해준다.

DFS 탐색 결과, 사이클 노드를 찾았으면 true를 반환받는데 이 때 현재 노드가 아까 위에서 기록한 사이클 노드의 시작점이 아니라면 현재 노드의 사이클 여부를 true로 표시하고 true를 리턴한다.

만약 현재 노드가 사이클 노드라면 이제 return 값은 false가 되어야 한다. 왜냐하면 현재 노드가 사이클 노드라고 판명되었다는 것은 DFS 탐색을 하고 복귀하는 중인데, 최초로 사이클 노드를 호출해서 방문 체크한 노드는 사이클 노드가 아니기 때문이다.

만약 true를 return한다면 사이클 노드와 인접한 모든 노드가 사이클로 표시되는 오류를 범할 수 있다. 따라서 사이클 노드의 출발점으로 돌아왔다면 이제는 false를 return해야 한다.

그 후 BFS를 통해 순환선까지의 거리를 구하는 것은 동일하다.

<br>

### 언어별 풀이 요약

| 언어   | 메모리   | 실행 시간(ms) | 시간복잡도 | 공간복잡도 | 풀이 시간 | 시도 횟수 | 해설 참고            |
| ------ | -------- | ------------- | ---------- | ---------- | --------- | --------- | -------------------- |
| Python | 34672 KB | 4160 ms       | O(N ^ 2)   | O(N)       | 60분      | 2         | :white_large_square: |
| Java   | 16372 KB | 196 ms        | O(N)       | O(N)       | 40분      | 1         | :white_check_mark:   |
| Kotlin |          |               |            |            |           |           |                      |

<br>

### 예외(테스트) 케이스

```
```

