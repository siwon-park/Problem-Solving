## [골3] Zoo (17821번)

[https://www.acmicpc.net/problem/17821]()

### 문제 유형

그래프 탐색, 그래프 이론, 다익스트라, 0-1 BFS

<br>

### 어려웠던 점 / 문제의 핵심

탈출한 동물들의 발자국을 보고, 최소 몇 마리의 동물이 탈출했는지 구하는 문제이다.

문제를 푸는데 도움이 될만한 힌트는 아래와 같다.

- 동물들은 다른 동물의 발자국이 있으면 그 발자국을 지우고 자신의 발자국을 남기면서 지나간다
- 동물들은 임의의 4방향으로 이동이 가능하고, 항상 최단 거리로만 가지는 않는다.
- 발자국 모양으로 가능한 케이스들이 정해져 있다.
  - 예를 들면, 좌측 상단 시작점의 동물 종류와 우측 하단 도착점의 동물 종류는 같아야 한다.
  - 또한 시작점 및 도착점의 인접한 곳에 최소 1개 이상의 같은 종류의 동물 발자국이 있어야 한다.

이 문제는 0-1 BFS로 문제를 풀 수 있다.

- 다음 위치가 눈 밭이 아니면서 지나간 동물 수를 체크하지 않았을 때만 이동한다.
  - 그래야만 최단 거리(최소 동물 수)를 구할 수 있다.
- 만약 현재 동물과 다른 동물의 발자국이 보인다면, 덱의 뒤에 삽입한다.
  - 이 때 다음 이동 위치에 지나간 동물의 수는 현재 위치의 지나간 동물의 수 + 1로 체크해준다.
- 그게 아니라 현재 동물과 같은 동물의 발자국이 보인다면, 덱의 앞에 삽입한다.
  - 이 때 다음 이동 위치에 지나간 동물의 수는 현재 위치의 지나간 동물의 수와 같다.

![image](https://github.com/user-attachments/assets/e9796e8b-ae03-4ede-a0fe-4a7972ba8d5f)

위의 그림에서 (1, 3)의 B와 (3, 3)의 B는 같은 동물이라고 볼 수 있고, (2, 3)의 B 발자국은 T에 의해 지워졌다는 시나리오가 가능하다.

실제로는 B가 먼저 도착했지만 0 - 1 BFS 탐색 로직 상으로는 나중에 도착한다. 이렇게 해야 하는 이유는 T가 먼저 도착하게 해야 (3, 3)의 B를 (1, 3)의 B에서 출발해서 도착하는 것보다 더 빨리 도착하게 되어 총 동물의 수를 최소로 유지할 수 있다.

최종적으로는 지나다닌 동물의 수를 체크한 방문 배열의 최댓값을 출력하면 된다.

<br>

### 언어별 풀이 요약

| 언어   | 메모리   | 실행 시간(ms) | 시간복잡도 | 공간복잡도 | 풀이 시간 | 시도 횟수 | 해설 참고          |
| ------ | -------- | ------------- | ---------- | ---------- | --------- | --------- | ------------------ |
| Python |          |               |            |            |           |           |                    |
| Java   | 61288 KB | 416 ms        | O(MN)      | O(MN)      | 70분      | 1         | :white_check_mark: |
| Kotlin |          |               |            |            |           |           |                    |

<br>

### 예외(테스트) 케이스

```
```

