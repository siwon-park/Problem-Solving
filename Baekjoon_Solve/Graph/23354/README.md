## [골3] 군탈체포조 (23354번)

[https://www.acmicpc.net/problem/23354]()

### 문제 유형

그래프 이론, 브루트포스, 다익스트라

<br>

### 어려웠던 점 / 문제의 핵심

0번은 출발 부대로 설정하고, 1번부터 최대 5번 탈영병별로 다익스트라 알고리즘을 돌려서 `i번 탈영병에서 출발하는 최단거리 테이블`을 구한다.

그 후, 백트랙킹 순열을 구성하여 출발지 → 도착지까지 가는 비용을 누적하여 계산한다. 여기서 위에서 말한 각 탈영병의 위치에서 출발하는 최단거리 테이블을 활용하는 것이다.

백트랙킹 순열을 구성할 떄 중요한 점이 있는데, `출발과 도착은 항상 0이라는 점`이다.

따라서 순열을 구성하는 수의 개수는 `탈영병의 수 + 2`개이다. 단, 순열의 마지막은 어차피 무조건 0이기 때문에 `탈영병의 수 + 1`개까지의 비용을 구한 다음, 마지막 탈영병에서 출발해서 제일 처음 출발지(`0`)까지의 비용을 더하기만 하면 된다.  처음에는 출발지(`0`)에서 어떤 탈영병을 먼저 잡으러 갈지 모르기 때문에 `0을 포함하여 순열을 구성하기 때문에 수를 1부터 카운트하는 것`이다.

![image](https://user-images.githubusercontent.com/93081720/233789338-2c53dd6f-8192-4b85-8c19-e4733b191b82.png)

<br>

### 언어별 풀이 요약

간선의 수가 N^2개, 노드의 수가 N개이므로, 다익스트라 알고리즘의 시간 복잡도인 O(ElogV)에서 O(N^2 logN)이 된다.

엄밀히 따지면 탈영병의 수인 M개만큼 다익스트라 알고리즘을 돌리기 때문에 O(M N^2 logN)이지만, M이 최대 5이기 때문에 전체 시간 복잡도에 유의미한 차이를 주기는 어렵다고 가정하여 O(N^2 logN)으로 표현하였음.

| 언어   | 메모리    | 실행 시간(ms) | 시간복잡도  | 공간복잡도 | 풀이 시간 | 시도 횟수 | 해설 참고            |
| ------ | --------- | ------------- | ----------- | ---------- | --------- | --------- | -------------------- |
| Python |           |               |             |            |           |           |                      |
| Java   | 227732 KB | 2064 ms       | O(N^2 logN) | O(N^2)     | 65분      | 1         | :white_large_square: |
| Kotlin |           |               |             |            |           |           |                      |

<br>

### 예외(테스트) 케이스

```
```

