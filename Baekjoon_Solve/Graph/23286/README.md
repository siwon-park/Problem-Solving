## [골3] 허들 넘기 (23286번)

https://www.acmicpc.net/problem/23286

### 문제 유형

그래프 이론, 플로이드-워셜, 다익스트라

<br>

### 어려웠던 점 / 문제의 핵심

#### 다익스트라

다익스트라 알고리즘으로 풀 경우, 출발지 `s`, 도착지 `t`가 정해져 있기 때문에 매번 다익스트라 알고리즘을 통해 최단 거리 테이블을 구해야 한다.

그렇게 되면 한번 구할 때마다 `O(ElogV)`가 걸릴텐데, 각 정점을 출발지로 가정한다면 모든 정점에 대해서 반복해야 하므로 `O(N * ElogV)`가 걸리게 된다.

간선의 개수 `M`이 최대 2만 5천이고, 정점의 수 `N`이 300이기 때문에 총 300 * 25000 * 8 = 60,000,000 (6천만)이다.

#### 플로이드

플로이드의 경우 간선의 수와 상관 없이 정점의 수 ^ 3만큼 시간 복잡도를 가지기 때문에, 300 ^ 3 = 27,000,000 (2천 7백만)이어서 다익스트라보다 더 빠르다.

그래서 플로이드 워셜로 풀었다.

구하고자 하는 값은 출발지 `s`에서 도착지 `t`로 가는 `경로 중 가장 높은 허들의 최솟값`이다. 즉, 경로 상에서 지나치는 허들 중 가장 높은 높이를 가진 허들이 있을 것이고, 여러 경로 중에서 이러한 가장 높은 허들의 높이 중 최솟값을 찾으라는 말이다.

이는 다음과 같이 구현할 수 있다.

보통 일반적인 플로이드 워셜 상에서 최단 비용은 `a → b`로 가는 비용과 `a → k`로 가는 비용 +  `k → b`로 가는 비용 중 더 작은 값을 택하게 된다.

하지만 우리가 구하고자 하는 값은 가장 높은 허들 중 최솟값이기 때문에  `a → k`로 가는 비용과  `k → b`로 가는 비용 중 더 큰 값을 선택하고, 해당 값과 `a → b`로 가는 비용 중 더 작은 값을 취하면 된다.

문제의 핵심인 플로이드 워셜 알고리즘은 아래와 같다.

```java
for (int k = 1; k < N + 1; k++) {
    for (int a = 1; a < N + 1; a++) {
        for (int b = 1; b < N + 1; b++) {
            if (graph[a][k] == -1 || graph[k][b] == -1) continue;
            int cost = Math.max(graph[a][k], graph[k][b]); // 더 큰 비용을 택함
            if (graph[a][b] == -1) graph[a][b] = cost;
            else graph[a][b] = Math.min(cost, graph[a][b]); // 최종적으론 더 작은 비용을 택함
        }
    }
}
```

<br>

### 언어별 풀이 요약

| 언어   | 메모리   | 실행 시간(ms) | 시간복잡도 | 공간복잡도 | 풀이 시간 | 시도 횟수 | 해설 참고            |
| ------ | -------- | ------------- | ---------- | ---------- | --------- | --------- | -------------------- |
| Python |          |               |            |            |           |           |                      |
| Java   | 31500 KB | 488 ms        | O(N ^ 3)   | O(N ^ 2)   | 30분      | 1         | :white_large_square: |
| Kotlin |          |               |            |            |           |           |                      |

<br>

### 예외(테스트) 케이스

```
```

