## [골4] 해킹 (10282번)

https://www.acmicpc.net/problem/10282

### 문제 유형

그래프 이론, 그래프 탐색, 다익스트라

<br>

### 어려웠던 점 / 문제의 핵심

컴퓨터 b가 감염되면 s초 후 컴퓨터 a도 감염된다고 했으므로, b → a로 가는데 s초가 걸린다고 해석하면 된다.

BFS 탐색으로 풀 경우 최악의 경우 테스트 케이스 당 O(SV)의 시간 복잡도를 가지게 된다. S는 간선의 가중치이다.

그리고 테스트케이스의 수 또한 고려한다면 O(TSV)로 O(T*10,000,000)이라는 시간 복잡도를 가지게 된다.

테스트 케이스 수가 10을 넘어가면 1억을 넘기 때문에 TLE를 받을 수도 있다.

따라서 주어지는 간선의 가중치가 다를 수 있기 때문에 BFS보다는 다익스트라로 푸는 것이 더 적절하다.

#### 실수했던 점

Java 풀이의 경우 마이너한 실수 때문에 2번 틀렸는데, 이유는 다음과 같다.

- 틀린 풀이

```java
static int[] dijkstra(int s) {
    // ... (중략) ...
    while (!pq.isEmpty()) {
        // ... (중략) ...
        if (nxtT < distance[nxt.node]) {
            distance[nxt.node] = nxtT;
            lastT = Math.max(lastT, nxtT); // 다익스트라 안에서 마지막 해킹 시간 갱신
            pq.add(new Pair(nxt.node, nxtT));
        }
    }

}
```

- 올바른 풀이

```java
static int[] dijkstra(int s) {
	// ... (중략) ...
    while (!pq.isEmpty()) {
		// ... (중략) ...
    }
    // 탐색을 다 끝낸 다음에 마지막 해킹 시간을 찾음
    for (int i = 1; i < distance.length; i++) {
        if (distance[i] != MAX) {
            lastT = Math.max(lastT, distance[i]);
            cnt += 1;
        }
    }
}
```

틀린 풀이의 경우 다익스트라로 그래프 탐색을 하는 도중에 마지막 해킹 시간을 갱신하는데, 이는 잘못된 풀이이다.

왜냐하면 다익스트라의 경우 최단 거리를 계속해서 갱신하면서 탐색하는데, 처음 방문한 노드의 해킹 시간이 반드시 최적의 해킹 시간이 아닐 수도 있기 때문이다.

따라서 잘못된 풀이의 코드는 처음 방문했을 때의 최악의(최대) 시간을 계속해서 갖고 있는 셈이 되어버리기 때문에 틀렸다.

<br>

### 언어별 풀이 요약

| 언어   | 메모리    | 실행 시간(ms) | 시간복잡도   | 공간복잡도 | 풀이 시간 | 시도 횟수 | 해설 참고            |
| ------ | --------- | ------------- | ------------ | ---------- | --------- | --------- | -------------------- |
| Python | 46684 KB  | 932 ms        | O(T * ElogV) | O(E)       | 30분      | 1         | :white_large_square: |
| Java   | 147280 KB | 848 ms        | O(T * ElogV) | O(E)       | 35분      | 3         | :white_large_square: |
| Kotlin |           |               |              |            |           |           |                      |

<br>

### 예외(테스트) 케이스

```
```

