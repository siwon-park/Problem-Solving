## [골5] 이진수 게임 (18112번)

https://www.acmicpc.net/problem/18112

### 문제 유형

그래프 이론, 그래프 탐색, BFS, 비트 마스킹

<br>

### 어려웠던 점 / 문제의 핵심

비트 마스킹 + BFS 문제. 범위도 작고 비트 수도 작아서 쉽게 풀 수 있다.

1번 연산은 보수 연산으로서, 특정 자리의 비트를 반전시켜야 하는 연산이다.

특정 자리의 비트를 토글링하는 방법은 비트 XOR 연산을 통해서 할 수 있다. 단, 이 때 주의할 점은 맨 앞자리의 1은 비트 반전 대상에서 제외시켜야 한다. (맨 앞자리 이상의 비트를 비트 토글링할 수 있으면 더 짧은 최단 거리가 가능하다.)

이는 특정 i번째 비트는 이상으로는 토글링이 불가능하다는 의미이다. 따라서 i번째 비트를 토글링할 수 있는지 판단하기 위해서는, `i + 1`번째 비트가 1인 수 중에서 가장 작은 수보다 현재 숫자(`num`)가 작아야 한다.

조금 다르게 표현하면 만약 `1 << i`로 비트를 시프트했을 때 시프트한 위치가 `num`의 맨 앞자리 비트라면, `1 << (i + 1)`을 하게 되면 무조건 `num`보단 클 수밖에 없다.

2번, 3번 연산은 현재 수에 +1, -1을 더하는 연산이니 크게 신경 쓸만한 내용은 없다.

<br>

### 언어별 풀이 요약

M = 이진수의 길이인 L과 K 중 더 큰 수

N = 1 << 10

| 언어   | 메모리   | 실행 시간(ms) | 시간복잡도 | 공간복잡도 | 풀이 시간 | 시도 횟수 | 해설 참고            |
| ------ | -------- | ------------- | ---------- | ---------- | --------- | --------- | -------------------- |
| Python |          |               |            |            |           |           |                      |
| Java   | 14360 KB | 128 ms        | O(10 * M)  | O(N)       | 45분      | 1         | :white_large_square: |
| Kotlin |          |               |            |            |           |           |                      |

<br>

### 예외(테스트) 케이스

```
1011
10
ans: 7

1101
110
ans: 4

1101
111
ans: 3

1100
110
ans: 3
```

