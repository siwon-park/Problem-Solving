## [골4] 옥수수밭 (30024번)

https://www.acmicpc.net/problem/30024

### 문제 유형

우선순위 큐, BFS, 그래프 이론, 그래프 탐색

<br>

### 어려웠던 점 / 문제의 핵심

우선순위 큐에 가장자리에 존재하는 옥수수를 가치가 큰 순서대로 담아서 BFS 탐색을 하면서 방문하는 순서를 출력하면 된다.

가장자리에 있는 옥수수를 넣을 땐, 간단하게 아래와 같이 구현하면 된다.

```java
if (i == 0 || i == N - 1 || j == 0 || j == M - 1) {
    pq.add(new Pair(i, j));
    visited[i][j] = true;
}
```

#### 실수했던 점

처음에 구현한 코드도 거의 맞았는데, 가장자리에 있는 옥수수를 넣는 로직이 잘못되었다.

```java
// 가장 자리에 있는 옥수수들을 우선순위 큐에 담음
for (int j = 0; j < M; j++) {
    pq.add(new Pair(0, j, graph[0][j]));
    pq.add(new Pair(N - 1, j, graph[N - 1][j]));
    inQueue[0][j] = true;
    inQueue[N - 1][j] = true;	
}

for (int i = 1; i < N - 1; i++) { // 여기서 잘못된 로직으로 구현함
    pq.add(new Pair(i, 0, graph[i][0]));
    pq.add(new Pair(i, M - 1, graph[i][M - 1]));
    inQueue[i][0] = true;
    inQueue[i][M - 1] = true;
}
```

`i`가 1부터 N - 1까지 순회하면서 각 행별 0열과 M - 1열에 존재하는 옥수수를 담는 코드이다.

뭐가 잘못됐을까?

만약 N이 2라면? 처음 for구문에 의해 1행과 2행의 데이터는 정상적으로 삽입된다.

그러나 여기서 더이상 탐색을 하지 말아야 한다. 이미 가장자리에 존재하는 옥수수는 모두 담았기 때문이다.

하지만 뒤에 for 구문에 의해 나머지 각 행별 0열과 M - 1열의 옥수수를 담기 위해 2행의 데이터를 중복해서 담게된다. 이것 때문에 BFS 탐색을 했을 때 오류가 생기는 것이다.

<br>

### 언어별 풀이 요약

| 언어   | 메모리    | 실행 시간(ms) | 시간복잡도        | 공간복잡도 | 풀이 시간 | 시도 횟수 | 해설 참고            |
| ------ | --------- | ------------- | ----------------- | ---------- | --------- | --------- | -------------------- |
| Python |           |               |                   |            |           |           |                      |
| Java   | 111632 KB | 1000 ms       | O(MN * 4 * logMN) | O(MN)      | 50분      | 2         | :white_large_square: |
| Kotlin |           |               |                   |            |           |           |                      |

<br>

### 예외(테스트) 케이스

```
```

