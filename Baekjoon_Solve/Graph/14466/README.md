## [골4] 소가 길을 건너간 이유 6 (14466번)

https://www.acmicpc.net/problem/14466

### 문제 유형

그래프 이론, 그래프 탐색, BFS, DFS

<br>

### 어려웠던 점 / 문제의 핵심

체감상 골드4는 아니고 골드3정도는 되는 문제인 것 같다.

처음에 도저히 문제가 이해가 안돼서 구글링해서 그림을 설명으로 그려놓은 것을 보고 나서야 이해되었다.

![image](https://github.com/siwon-park/Problem-Solving/assets/93081720/3515a60e-10f7-48f9-95ff-cac4c1096e3f)

그런데 문제는 중복없이 쌍의 개수를 카운트하는 아이디어가 떠오르지 않아서 고민을 좀 하다가 며칠 뒤에 아이디어가 떠올라서 풀었다.

내가 푼 풀이의 핵심은 `연결 컴포넌트의 개수`와 `각 컴포넌트에 속한 소의 개수`를 구하는 것이다.

문제가 이해가 안 되었던 부분이 바로 `길`이었는데, 길을 건너지 않고서는 만날 수 없는 소의 쌍을 구하는 것이기 때문에 사실상 길이 아니라 `장애물`로 해석하는 것이 올바르다.

길은 메모리 절약을 위해서 비트로 길의 유무를 판별하였다. 1111, 1010, 0110 등과 같이 해당 방향에 길이 있음을 비트로 표시하였다.

BFS 탐색을 통해서 다음 위치로 가는데 길을 거쳐서 가지 않는 경우에 대해서만 같은 연결 컴포넌트로 연결한다. 그리고 해당 위치가 소일 경우에만 해당 컴포넌트의 수를 증가시켜준다.

최종적으로 연결 컴포넌트의 수만큼 2중 for문으로 순회하여, 각 연결 컴포넌트에 속한 소의 수를 곱하면 서로 길을 건너지 않고는 만날 수 없는 소의 쌍을 중복없이 구할 수 있다.

<br>

### 언어별 풀이 요약

| 언어   | 메모리   | 실행 시간(ms) | 시간복잡도   | 공간복잡도 | 풀이 시간 | 시도 횟수 | 해설 참고            |
| ------ | -------- | ------------- | ------------ | ---------- | --------- | --------- | -------------------- |
| Python |          |               |              |            |           |           |                      |
| Java   | 20416 KB | 228 ms        | O(4 * (N^2)) | O(N^2)     | 60분      | 1         | :white_large_square: |
| Kotlin |          |               |              |            |           |           |                      |

<br>

### 예외(테스트) 케이스

```
```

