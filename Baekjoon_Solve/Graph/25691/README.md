## [골5] k개 트리 노드에서 사과를 최대로 수확하기 (25691번)

[https://www.acmicpc.net/problem/25691]()

### 문제 유형

그래프 이론, 그래프 탐색, BFS, 비트마스킹, 브루트포스

<br>

### 어려웠던 점 / 문제의 핵심

비트마스킹 + BFS

문제 설명과 예시에서 알 수 있듯이 사과를 최대한 많이 얻기 위해 특정 노드로 갔다가 다시 돌아와서 다른 노드로 이동할 수도 있다. 따라서 방문 상태에 따라 방문을 다르게 할 수 있기 때문에 비트마스킹 + BFS로 탐색해야 함을 알 수 있다.

2차원의 배열을 선언한다고 해도 n이 최대 17이니 `(2 ^ 16 - 1) * 17` = 1,114,095로 110만 밖에 되지 않는다. 따라서 비트마스킹 + BFS로 방문 여부를 체크해가면서 풀어도 시간적, 공간적으로 충분히 안전하다.

<br>

### 언어별 풀이 요약

| 언어   | 메모리   | 실행 시간(ms) | 시간복잡도    | 공간복잡도    | 풀이 시간 | 시도 횟수 | 해설 참고            |
| ------ | -------- | ------------- | ------------- | ------------- | --------- | --------- | -------------------- |
| Python |          |               |               |               |           |           |                      |
| Java   | 36456 KB | 252 ms        | O(N * (2 ^N)) | O(N * (2 ^N)) | 45분      | 1         | :white_large_square: |
| Kotlin |          |               |               |               |           |           |                      |

<br>

### 예외(테스트) 케이스

```
```

