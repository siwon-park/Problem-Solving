## [플5] 비밀번호 제작 (20304번)

https://www.acmicpc.net/problem/20304

### 문제 유형

그래프 이론, 그래프 탐색, BFS, 비트마스킹

<br>

### 어려웠던 점 / 문제의 핵심

안전도는 비밀번호와의 안전거리(다른 비트의 개수)중 `최솟값`으로 정의하고, 우리가 찾아야 하는 값은 (최소) 안전도 중 `최댓값`이다.

주어지는 N에 대해서 N의 비트 수를 구한다.

- 이는 계속해서 2로 나눠주면서 구하면 된다.

크기가 N + 1인 방문 배열을 비트 수 + 1의 값으로 초기화한다. 

그리고 큐에 해커가 비밀번호로 시도한 번호들을 넣고 해당 숫자의 방문 배열의 값을 0으로 마킹한다.

BFS 탐색을 하면서 큐에서 숫자를 하나 뽑고 이를 num이라 하자.

그 후, 0부터 max까지 순회하면서 비트 XOR연산을 통해 비트 토글링을 실시한다.

```java
int newNum = num ^ (1 << i); // 비트 XOR 연산을 통한 토글링
```

이렇게 해서 나온 newNum이 N보다 크면 인덱스 범위를 벗어나기 때문에 무시하고,

그게 아니라면 새로운 숫자에 해당하는 방문 배열의 값을 현재 숫자에 해당하는 방문 배열의 값 + 1로 마킹해준다.

왜냐하면 비트 토글링 연산을 했다는 의미는 `num과 i번째 비트만 다르다`는 의미이기 때문에 서로 다른 비트 수의 차이가 딱 1이기 때문이다.

그 후, N + 1번 순회하여 방문하지 않은 숫자는 무시하고, 안전도의 최댓값을 찾으면 된다.

<br>

### 언어별 풀이 요약

| 언어   | 메모리   | 실행 시간(ms) | 시간복잡도 | 공간복잡도 | 풀이 시간 | 시도 횟수 | 해설 참고          |
| ------ | -------- | ------------- | ---------- | ---------- | --------- | --------- | ------------------ |
| Python |          |               |            |            |           |           |                    |
| Java   | 71640 KB | 564 ms        | O(N*max)   | O(N)       | 60분      | 2         | :white_check_mark: |
| Kotlin |          |               |            |            |           |           |                    |

<br>

### 예외(테스트) 케이스

```
```

