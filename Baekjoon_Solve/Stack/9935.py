# 문자열 폭발(9935번)
##################################################################################
    # 문제: https://www.acmicpc.net/problem/9935
    # 스택, 문자열
    # 이 문제를 처음 얼핏 봤을 때, replace와 join을 반복해서 사용해야하나 생각했는데 시간초과가 날 게 뻔했다.
    # 다시 살펴보니 스택 문제임을 직감했고 풀이를 시도했으나, 첫 시도는 인덱스에러 판정을 받았다.
    # 로직은 분명히 맞다고 생각해서 인덱스 에러만 고치면 되는 상황이라고 생각했다.
    # 어디서 인덱스 에러가 날 만한 곳은 2곳이었지만, 어떤 케이스에서 나는지 테스트를 잠깐 해봐도 찾을 수 없었다.
    # 그러다가 BABA AB를 입력했을 때, BA를 출력해야 함에도 BABA를 그대로 출력하는 반례를 질문 게시판을 통해 찾을 수 있었다.
    # 인덱스 에러에 대한 케이스는 아니었지만 사실 결과적으로 인덱스 에러가 나는 이유도 여기에 있었다. 폭발 문자열의 길이만큼 비교를 해줬으면
    # break를 하거나 while구문을 돌리면 안 됨에도 불구하고, 즉 n < 0임에도 stack[-1] == BS[n]에 대해 비교를 하고 있었다.
    # 이러니까 내가 설계했던 로직과는 다르게 동작하여 에러 및 잘못된 결과를 반환하고 있었던 것이다.
    # (상세 풀이는 코드를 참고)
##################################################################################
import sys
input = sys.stdin.readline

S = list(input().rstrip())
BS = input().rstrip()
N = len(BS)

# 일단 S에 있는 문자열을 스택에 다 밀어 넣되,
# BS의 끝 문자열이 들어오면 폭발이 되는지 확인하여 없애버림
stack = []
for s in S:
    if s == BS[-1]:
        n = N - 2 # -1을 비교했으니 그 전부터 비교
        tmp_stack = []
        while stack and n >= 0 and stack[-1] == BS[n]:
            tmp_stack.append(stack.pop())
            n -= 1
        if n != -1: # n != -1이면 폭발 문자열과 완전히 일치 X
            while tmp_stack: # tmp_stack에서 뽑아서 되돌려줌
                stack.append(tmp_stack.pop())
            stack.append(s) # 마지막에 들어오는 문자열까지도 넣어줌
    else:
        stack.append(s)

print("".join(stack) if stack else "FRULA")
