## [플5] 비숍 (1799번)

https://www.acmicpc.net/problem/1799

### 문제 유형

백트랙킹

<br>

### 어려웠던 점 / 문제의 핵심

시간 제한 10초, 메모리 제한 128MB로 최적화를 하지 않으면 절대 통과할 수 없다.

#### (1) O(1)로 대각선 체크하기

대각선 체크를 위해 Set 자료형을 사용하면 메모리 초과, 그 외 반복문을 사용하면 시간 초과가 발생한다.

하지만 O(1)의 시간복잡도로 대각선을 체크하는 방법이 있다. 대각선의 성질을 이용하는 것이다.

- 좌상-우하 대각선은 각 좌표 간 r - c의 값이 일정하다. (단, r < c의 경우 음수이기 때문에 N - 1을 더해준다.)
  - r - c가 가질 수 있는 범위가 - (N - 1) ~ (N - 1)이기 때문에 좌표를 옮겨서 N - 1을 더해준 것임.
- 좌하-우상 대각선은 각 좌표 간 r + c의 값이 일정하다.

따라서 같은 값이면 같은 대각선 위에 위치한다는 의미이다.

따라서 크기가 2 * N - 1인 대각선 체크용 배열을 만들고, 이 배열에 이미 방문 체크가 되어 있으면 해당 대각선 상에는 비숍을 놓았다고 볼 수 있다.

#### (2) 흰색칸, 검은색칸 나눠서 백트랙킹하기

체스에서 비숍의 특징은 대각선으로만 움직일 수 있다는 것이다. 즉, 한 번 놓이면 같은 색 칸에서만 움직이게 된다. 이 말은 비숍이 서로 공격 가능하려면 같은 색 칸에서만 가능하다는 것이다.

서로 공격하지 않게 비숍을 배치하려면 흰색 칸의 경우 흰색 칸에 놓이는 비숍만, 검은색 칸의 경우 검은색 칸에 놓이는 비숍만 신경써도 충분하다.

따라서 굳이 흰색, 검은색 모두 공격 가능 유무를 체크하는 낭비를 할 필요 없이, 흰색 칸에 대해서만 탐색 / 검은색 칸에 대해서만 탐색하는 것이다.

전체 백트랙킹의 경우 최악의 경우 2 ^ 100이지만, 두 개로 나눌 경우 2 ^ 50 + 2 ^ 50이다.

결론적으로 정답은 흰색 칸 백트랙킹의 최댓값 + 검은색 칸 백트랙킹의 최댓값이 된다.

<br>

### 언어별 풀이 요약

| 언어   | 메모리   | 실행 시간(ms) | 시간복잡도 | 공간복잡도 | 풀이 시간 | 시도 횟수 | 해설 참고          |
| ------ | -------- | ------------- | ---------- | ---------- | --------- | --------- | ------------------ |
| Python |          |               |            |            |           |           |                    |
| Java   | 14668 KB | 164 ms        | O(2^(N/2)) | O(N)       | 60분      | 15        | :white_check_mark: |
| Kotlin |          |               |            |            |           |           |                    |

<br>

### 예외(테스트) 케이스

```
```

