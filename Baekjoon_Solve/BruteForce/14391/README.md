## [골3] 종이 조각 (14391번)

https://www.acmicpc.net/problem/14391

### 문제 유형

브루트포스, 비트 마스킹

<br>

### 어려웠던 점 / 문제의 핵심

비트 마스킹 + 백트랙킹으로 문제를 해결하였다.

`가로`로 자른 경우를 `1`, `세로`로 자르는 경우를 `0`이라고 할 때 아래 그림과 같이 비트를 만들 수 있다. 

![image](https://github.com/siwon-park/Problem_Solving/assets/93081720/e0f19298-de9a-4e84-a7fb-70fe6fda88eb)

솔직히 비트 마스킹을 안 쓰고 풀 수도 있는데, 그렇게 하면 방문 배열을 추가적으로 선언해서 사용해야 하므로 메모리상 비효율적이고, 백트랙킹에서 다음 함수를 호출하는 로직이 조금 변경된다. 모든 경우를 고려하려면 M열까지 탐색하고 난 다음에 k + 1행으로 넘어가야 하기 때문이다. (그런데 M과 N의 크기가 작아 메모리상 영향을 주는 정도는 미미하다.)

하지만 비트 마스킹을 사용할 경우, M의 크기만큼 최대 비트를 가진 숫자까지 선언하면 되므로 M <= 4이니 1111(2) == 15이다.

즉, 0 ~ (1 << M) - 1에 해당하는 숫자를 각 행별로 넣고 백트랙킹 연산하면 된다.

그리고 N행까지 탐색을 마쳤을 때, 최종적으로 가로로 자른 것에 대한 연산과 세로로 자른 것에 대한 연산을 해주면 된다. 

- 가로의 경우 열의 인덱스와 비트 연산 결과가 1일 경우에 임시 누적합을 계산해주고, 비트 연산 결과가 0이면 총합에 누적해준다.
- 세로의 경우 열의 인덱스와 비트 연산 결과가 0일 경우에 임시 누적합을 계산해주고, 비트 연산 결과가 0이 아니면 총합에 누적해준다.

<br>

### 언어별 풀이 요약

| 언어   | 메모리   | 실행 시간(ms) | 시간복잡도     | 공간복잡도 | 풀이 시간 | 시도 횟수 | 해설 참고            |
| ------ | -------- | ------------- | -------------- | ---------- | --------- | --------- | -------------------- |
| Python |          |               |                |            |           |           |                      |
| Java   | 17884 KB | 196 ms        | O((2 ^ M) ^ N) | O(MN)      | 40분      | 1         | :white_large_square: |
| Kotlin |          |               |                |            |           |           |                      |

<br>

### 예외(테스트) 케이스

```
```

