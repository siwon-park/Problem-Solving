## [골4] 방 번호 (15668번)

https://www.acmicpc.net/problem/15668

### 문제 유형

수학, 브루트포스

<br>

### 어려웠던 점 / 문제의 핵심

브루트포스를 사용해서 간단하게 풀 수 있는 문제이지만, 백트랙킹을 좀 더 연습해보려고 백트랙킹으로 풀었다.

#### 실수했던 점

처음 백트랙킹을 구현했을 때, 0 ~ 9 사이의 숫자를 선택하면서 현재 사용하지 않았다면 선택을 하고

`A * 10 + i`를 해주거나, `B * 10 + i`를 해주는 방식으로 A와 B 둘 중 하나에 숫자를 추가해서 `A + B = N`을 만족하는지 확인하는 방식으로 구현하였다.

이 방법은 최적화가 되지 않은 최악의 방법으로 숫자가 커질 수록 탐색해야 하는 경우의 수가 매우 많기 때문에 비효율적인 풀이 방법이었다.

#### 백트랙킹 최적화

잘 생각해보면 `A + B = N`이기 때문에 `N - A = B`이다. 따라서 A와 B, 두 가지로 나눠서 생각할 필요 없이 A 하나에 대해서만 생각해도 된다.

B를 A보다 작은 수로 가정하고, A > N이면 return하여 백트랙킹한다.

만약 A < N이면 B(=N - A)에 대해서 탐색하여, A에 사용된 숫자와 B에 사용된 숫자를 확인하여 2번 이상 사용된 숫자가 없으면 서로 다른 숫자를 사용하여 A + B = N을 만족시키는 A와 B를 찾은 것이기 때문에 함수 호출을 종료한다. 이는 flag 변수를 사용해서 재귀 호출을 방지하면 된다.

※ 위 방법 그대로 제출하면 `524ms`로 조금 느리게 동작하지만, 아래에서 브루트포스 방식에서 사용한 방법을 통해 최적화를 하면 `172ms`로 훨씬 빨라진 속도로 동작한다. 메모리 또한 눈에 띄게 덜 사용함을 확인할 수 있다.

![image](https://github.com/siwon-park/Problem_Solving/assets/93081720/b379002c-99df-48b6-98f5-29826959f65f)

#### 브루트포스

제일 효율적인 풀이 방법은 브루트포스 풀이이다.

N이 최대 10 ^ 9인데, A + B = N을 만족하는 A와 B 중 한쪽을 작은 수라고 가정한다면, 작은 수는 최대 10만이다.

왜냐하면 사용할 수 있는 숫자는 0 ~ 9 각 각 1개씩인데, 일단 작은 수만 조건을 만족한다고 가정하면 최대 5개의 숫자를 고를 수 있으므로 가장 큰 수만 차례대로 5개를 고르면 `98765`이기 때문이다.

따라서 작은 수의 범위를 최대 10만으로 잡고, `N - 작은 수`와 `작은 수`의 자리 수를 체크해서 중복 사용된 숫자가 없으면 해당 숫자가 정답이다. 

(브루트포스 풀이는 다른 분의 풀이를 참고해서 가져왔다.)

<br>

### 언어별 풀이 요약

단, 여기서 말하는 M은 최대 10만이다.

| 언어   | 메모리   | 실행 시간(ms) | 시간복잡도 | 공간복잡도 | 풀이 시간 | 시도 횟수 | 해설 참고            |
| ------ | -------- | ------------- | ---------- | ---------- | --------- | --------- | -------------------- |
| Python |          |               |            |            |           |           |                      |
| Java   | 17264 KB | 172 ms        | O(M)       | O(1)       | 40분      | 1         | :white_large_square: |
| Kotlin |          |               |            |            |           |           |                      |

<br>

### 예외(테스트) 케이스

```
```

