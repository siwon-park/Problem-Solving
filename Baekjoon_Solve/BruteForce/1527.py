# 금민수의 개수(1527번)
##################################################################################################
    # 문제: https://www.acmicpc.net/problem/1527
    # 브루트포스
    # dfs를 활용해서 완전탐색을 구현하였다. 게다가 이번에는 저번에 문제를 풀면서 배운 약간의 스킬을 사용했다
    # 숫자 → 문자, 문자 → 숫자 변환 개념을 사용하지 않고, 10을 곱해서 10의 자리씩 계속 밀게 만들고 그 뒤에 4나 7을 붙이는 방식으로 구현하였다.
    # 4와 7을 붙여나간 숫자가 B보다 크면 return 하여 탐색을 종료하고, A <= num <= B일 경우에만 집합에 넣어서 최종적으로 집합 안에 있는 수의 개수를 출력하였다.
##################################################################################################
import sys
sys.setrecursionlimit(int(1e5))
input = sys.stdin.readline

A, B = map(int, input().split())
S = set()

def dfs(num):
    if num > B:
        return
    if A <= num <= B:
        S.add(num)
    # 뒤에 4를 붙임
    dfs(num*10 + 4)
    # 뒤에 7을 붙임
    dfs(num*10 + 7)

dfs(0)
print(len(S))
