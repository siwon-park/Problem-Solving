## [골5] 세 친구 (17089번)

https://www.acmicpc.net/problem/17089

### 문제 유형

브루트포스, 그래프 이론

<br>

### 어려웠던 점 / 문제의 핵심

3중 for문으로 구현해도 시간초과가 나지 않는다.

그 이유는 절대 `O(N^3)`의 시간 복잡도가 될 수 없기 때문이다. 최악의 경우 시간 복잡도는 다음과 같이 계산할 수 있다. (내 풀이와 다르지만 어쨌든 O(1)로 친구 관계를 확인하기 위해 set을 쓴다는 점은 동일)

아래 코드를 예시로 참고하면,

```java
for (int a = 1; a <= n; a++) {
        for (int b = a+1; b <= n; b++) {
            if (a와 b사이에 간선이 있으면) {
                for (int c = b+1; c <= n; c++) {
                    if (a와c가 친구고, c와 b가 친구면) {
```

a와 b를 오름차순 조합으로 구한다. 이는 `O(N^2)`이다. 그런데 이 때, a와 b는 반드시 친구 관계여야만 한다.

그리고 a와 b가 친구 관계인 경우는 간선의 수 `M`과 같다. 이를 감안해서 a와 b가 친구 관계인 경우에 대해서만 b보다 큰 c에 대해 탐색하는 경우를 계산하면 `O(MN)`이다.

여기서 핵심은 `O(N^2)으로 고르는 시간 복잡도의 사건과 O(MN)의 사건은 별개`라는 것이다.

O(M * N^2)이라고 생각할 수도 있는데, 사실 우리는 N^2으로 돌다가 둘이 친구일 경우에만 N번 더 탐색하기 때문에 둘이 친구가 아니면 N번 더 탐색하지 않는다. 그리고 둘이 친구 관계일 때는 M번밖에 없기 때문에 최종적으로 시간 복잡도는 `O(N^2 + MN)`이다.

나의 경우 `세 친구의 합`은 결국 `세 친구의 친구 수 합 - 6 (=각자의 관계)`라는 점에서 착안하여,

- 세 친구가 서로 친구이려면 최소한 각자 2번 이상의 관계가 필요하다는 점.
- 이를 통해 세 친구의 합을 처음 구하고 나면 해당 합을 이용해서 컷팅을 할 수 있다는 점

을 가지고 문제를 풀었다.

<br>

### 언어별 풀이 요약

| 언어   | 메모리   | 실행 시간(ms) | 시간복잡도  | 공간복잡도 | 풀이 시간 | 시도 횟수 | 해설 참고            |
| ------ | -------- | ------------- | ----------- | ---------- | --------- | --------- | -------------------- |
| Python |          |               |             |            |           |           |                      |
| Java   | 18244 KB | 224 ms        | O(N^2 + MN) | O((MN)/2)  | 35분      | 2         | :white_large_square: |
| Kotlin |          |               |             |            |           |           |                      |

<br>

### 예외(테스트) 케이스

```
```

