## [실5] 세 부분 (2993번)

https://www.acmicpc.net/problem/2993

### 문제 유형

구현, 문자열, 브루트포스, 정렬

<br>

### 어려웠던 점 / 문제의 핵심

백트랙킹을 사용하여 문자열의 인덱스 중 2개의 인덱스를 선택하는 조합을 찾는다.

첫 번째 인덱스(idx1), 두 번째 인덱스(idx2)가 있다고 할 때

원래 문자열에서 `[0:idx1]`, `[idx1:idx2]`, `[idx2:N]`인 부분 문자열을 찾고 뒤집은 다음 순서대로 붙이고

문자열 비교 연산을 통해 사전순으로 더 빠른 문자열을 찾는다.

#### 주의할 점

자른 부분 문자열의 길이가 반드시 `0`이상이어야 한다.

예제 3번을 보면 자른 부분 문자열의 길이가 0보다 커야 한다는 것을 알 수 있지만 문제에서 명시되어 있지 않아서 실수하면 어디가 잘못 되었는지 못 찾을 수도 있겠다는 생각이 들었다. (자른 부분 문자열의 길이가 0이상이 허용되면 예제 3번의 답은 다르게 나온다.)

이미 `세 단어`라는 말에서 나눈 부분 문자열의 길이가 0보다 크다고 유추할 수는 있다. 그러나 그래도 문제에서 명시가 되어 있으면 더 좋겠다는 생각이 든다.

<br>

### 언어별 풀이 요약

| 언어   | 메모리   | 실행 시간(ms) | 시간복잡도 | 공간복잡도 | 풀이 시간 | 시도 횟수 | 해설 참고            |
| ------ | -------- | ------------- | ---------- | ---------- | --------- | --------- | -------------------- |
| Python |          |               |            |            |           |           |                      |
| Java   | 15168 KB | 132 ms        | O(N)       | O(1)       | 40분      | 1         | :white_large_square: |
| Kotlin |          |               |            |            |           |           |                      |

<br>

### 예외(테스트) 케이스

```
```

