## [골5] 넴모넴모 (Easy)

https://www.acmicpc.net/problem/14712

### 문제 유형

브루트포스, 백트랙킹

<br>

### 어려웠던 점 / 문제의 핵심

#### 브루트포스

현재 위치에 넴모를 놓는 경우와 넴모를 놓지 않는 경우를 나눠서 탐색하고 마지막에 완전 탐색을 통해서 2x2배열에 모두 넴모가 배치되어 있지 않은 경우의 수만 카운트하여 계산한다.

모든 경우의 수 탐색 + 매번 격자판을 전부 순회해야 하므로 시간 복잡도는 `O((MN)^2)`이다.

#### 최적화

마지막에 완전 탐색을 통해 2x2 배열에 모두 넴모가 있는 경우를 탐색하는 것을 하지 말고,

`매번 현재 위치에 넴모를 놓기 전에 넴모를 놓을 수 있는 경우에만 놓는 방법`을 사용해보자.

2x2 배열상에서 좌측상단부터 두면 이를 체크하기 거의 불가능하기 때문에, 2x2배열 상에서 우측하단인 `(2, 2)`위치에 넴모를 두기 시작한다고 가정하자.

이를 위해 배열의 크기를 행, 열 모두 1씩 크기를 더 키워서 사용하면 된다. 물론 0번 행과 열은 모두 사용하지 않는다.

다음 위치 탐색은 다음과 같이 수학적으로 계산할 수 있다.

```java
// 보통 일반적인 경우 0번 인덱스를 사용하기 때문에, (r, c)의 다음 위치는 다음과 같다.
backtrack(r + ((c + 1) / M), (c + 1) % M);

// 하지만 1번 인덱스부터 사용한다면, (r, c)의 다음 위치는 다음과 같다.
backtrack(r + (c / M), (c % M) + 1);
```

<br>

### 언어별 풀이 요약

| 언어     | 메모리   | 실행 시간(ms) | 시간복잡도 | 공간복잡도 | 풀이 시간 | 시도 횟수 | 해설 참고            |
| -------- | -------- | ------------- | ---------- | ---------- | --------- | --------- | -------------------- |
| Python   |          |               |            |            |           |           |                      |
| Java (1) | 18448 KB | 1352 ms       | O((MN)^2)  | O(MN)      | 30분      | 1         | :white_large_square: |
| Java (2) | 15636 KB | 552 ms        | O(MN)      | O(MN)      | 30분      | 1         | :white_check_mark:   |
| Kotlin   |          |               |            |            |           |           |                      |

<br>

### 예외(테스트) 케이스

```
```

