## [골1] 동전 뒤집기 (1285번)

https://www.acmicpc.net/problem/1285

### 문제 유형

그리디, 브루트포스, 비트마스킹

<br>

### 어려웠던 점 / 문제의 핵심

N이 최대 20이라고 해서 백트랙킹 + 브루트포스로 구현하게 되면

최악의 경우의 수는 2 ^ 20 * 2 ^ 20 = 2 ^ 40이라는 어마어마한 수만큼 연산해야 한다.

하지만 행 또는 열 하나에 대해서만 백트랙킹 + 브루트포스로 연산하고, 브루트포스로 연산하지 않은 열이나 행에 대해서는 그리디하게 연산하면 (2 ^ 20) * (20 * 20)으로도 가능하게 된다.  계산하면 419,430,400으로 약 4억이다.

T는 뒤집으면 H가 되고, H는 뒤집으면 T가 된다.

최소 T의 개수를 찾는 것이기 때문에 현재 H가 과반 이상이면 뒤집지 않고, 현재 H가 과반 이하면 뒤집는다. 그래야만 그리디하게 T가 더 적은 방향으로 갈 수 있다.

H와 T의 개수는 비트 마스킹(비트 연산)을 통해 빠르게 찾을 수 있다.

비트 반전 연산이 필요했는데 오해가 있었다.

예를 들어 6을 비트 NOT(~) 연산하게 되면 이진수로 표현했을 때 110 → 001이 되어 1이 되어야 하는 줄 알았는데 컴퓨터는 보수의 개념이 있기 때문에 ~6을 그대로 출력하면 -7이 된다. 그래도 비트 연산을 계속하는 것에 있어서는 아무 문제 없으니 상관 없다.

<br>

### 언어별 풀이 요약

| 언어   | 메모리   | 실행 시간(ms) | 시간복잡도         | 공간복잡도 | 풀이 시간 | 시도 횟수 | 해설 참고            |
| ------ | -------- | ------------- | ------------------ | ---------- | --------- | --------- | -------------------- |
| Python |          |               |                    |            |           |           |                      |
| Java   | 15452 KB | 608 ms        | O(2 ^ N * (N ^ 2)) | O(N)       | 60분      | 1         | :white_large_square: |
| Kotlin |          |               |                    |            |           |           |                      |

<br>

### 예외(테스트) 케이스

```
```

