#합분해(2225번)
###################################
    # 문제: https://www.acmicpc.net/problem/2225
    # 다이나믹 프로그래밍
    # 1032ms 소요, O(N^2)으로 풀 수도 있지만 점화식 대로 구현함(O(N^3))
    # dp[N][K]를 0 ~ N까지의 정수 중 K개를 이용하여 N을 만들 수 있는 경우의 수라고 하면
    # 점화식은 dp[N][K]=dp[0][K-1]+dp[1][K-1]+...+dp[N-1][K-1]+dp[N][K-1]이다.
    # 추가적으로 모든 정수에 대하여 dp[N][1]=1이다. 숫자 1개를 이용해 정수 하나를 만드는 경우는 자기자신 뿐이니까 그렇다.(dp[N][0]=0)
    # 예를 들어, 2 이하의 숫자 2개를 이용하여 2를 만든다고 하면(dp[2][2]), 숫자 1개를 이용해 2 이하의 수를 만드는 경우의 수를 찾아야한다.
    # 해당 경우는 숫자 1개를 이용해 2를 만드는 경우에 0을 더하고(dp[2][1]), 숫자 1개를 이용해 1을 만드는 경우에 1을 더하면 2가 되고(dp[1][1]),
    # 마지막으로 숫자 1개를 이용해 0을 만드는 경우에 2를 더하면 2가 된다.(dp[2][0]). 차례대로 풀어쓰면 (2+0), (1+1), (0+2)이다. 해당 경우의 수는 3개이므로,
    # dp[2][2]=3이다.
    # 즉, 0 ~ N까지의 정수 중 K개를 이용하여 N을 만드려면 0 ~ N까지의 정수 중 K-1개 이용하여 0 ~ N을 만드는 경우를 다 더하면 되는 것이다.
###################################
N,K=map(int,input().split())
dp=[[0]*(K+1) for i in range(N+1)]
for i in range(N+1):
    dp[i][1]=1
    for j in range(2,K+1):
        for k in range(i+1):
            dp[i][j]+=dp[k][j-1]
print(dp[N][K]%int(1e9))
