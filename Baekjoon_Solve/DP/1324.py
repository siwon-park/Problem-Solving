# 젠장(1324번)
####################################################################################
    # 문제: https://www.acmicpc.net/problem/1324
    # DP
    # 생각보다 고민을 많이 했고, 2차원의 배열 DP까지도 고려했는데, 1차원으로 풀리는 문제였다.
    # 그런데 문제 지문이 이상한건지, 이전날 선택했던 쓰레기보다 크거나 같음이 아니고 큰 경우에만 주워야 하는 듯하다.
    # 일단 맨 처음에 매번 주울 수 있는 쓰레기의 수를 0으로 초기화하고,
    # 첫날 쓰레기와 둘째날 쓰레기가 일치하면, dp[j]에 dp[j]와 cnt + 1의 값 중 큰 값을 기록한다. 하나 더 주울 수 있으니 말이다.
    # 그리고 만약에 둘째날 쓰레기보다 첫째날 쓰레기가 더 크고, dp[j]의 값이 cnt보다 크면
    # 둘째날 또는 이전의 어느 시점에 특정 쓰레기의 수만큼 주웠다는 의미이고, 이 이후에 첫째날 쓰레기의 크기와 둘째날 쓰레기의 크기가 같다면
    # 해당 쓰레기를 주울 수 있게 되니, dp[j]의 값을 지금까지 주웠던 특정 쓰레기의 수로 갱신해준다.
    # 또한 최대한 주울 수 있는 쓰레기의 양은 dp[j]와 max_cnt를 비교한 값 중 더 큰 값으로 갱신해준다. 그 이유는 2중 for문에서 j가 1부터 N까지
    # 반복되므로, dp[j]값이 이미 지나왔었지만, 갱신될 수 있기 때문이다.
####################################################################################
import sys
input = sys.stdin.readline

N = int(input())
lst1 = [0] + list(map(int, input().split()))
lst2 = [0] + list(map(int, input().split()))

dp = [0] * (N + 1)
max_cnt = 0
for i in range(1, N + 1):
    cnt = 0
    for j in range(1, N + 1):
        if lst1[i] == lst2[j]: # 첫날 쓰레기와 둘째날 쓰레기가 일치하면
            dp[j] = max(dp[j], cnt + 1)
        if lst1[i] > lst2[j] and dp[j] > cnt: # 둘째날 쓰레기를 선택했다면, 다음에 첫째날에 선택하는 쓰레기는 둘째날 선택했던 쓰레기보다 커야함
            cnt = dp[j]
        max_cnt = max(max_cnt, dp[j])
print(max_cnt)
