## [골5] 1학년 (5557번)

[https://www.acmicpc.net/problem/5557]()

### 문제 유형

DP

<br>

### 어려웠던 점 / 문제의 핵심

아이디어를 떠올리기 어렵지 않은 DP 문제였다.

어떤 숫자 `j`을 만들기 위해 사용한 연산자의 수 `i`에 대한 2차원의 DP 배열을 만들어서(`dp[i][j]`)

최종적으로 연산 결과가 `arr[n - 1]`이 나오는 경우의 수를 출력하면 된다. 

`n`개의 숫자가 주어진다면, 등호 `=`을 포함하여 사용할 수 있는 연산자(`+`, `-`)의 개수는 `n - 1`개이고,

마지막에는 `arr[n - 1]`과 연산을 하는 것이 아니라, 그전까지의 연산 결과가 `arr[n - 1]`이 되는지 확인하는 것이므로 실제 사용하는 연산자의 개수는 `n - 2`개이다.

중간 연산 결과가 `0 이상 20 이하`여야 하므로 `+`연산의 결과가 20 이하일 경우, `-`연산의 결과가 0 이상일 경우에 DP 배열을 갱신한다.

점화식은 다음과 같다.

`dp[i][j + arr[i]] += dp[i - 1][j]`, `dp[i][j - arr[i]] += dp[i - 1][j]`

![image](https://user-images.githubusercontent.com/93081720/233271786-81125b92-4313-416a-becc-026501c810fc.png)

<br>

### 언어별 풀이 요약

| 언어   | 메모리   | 실행 시간(ms) | 시간복잡도 | 공간복잡도 | 풀이 시간 | 시도 횟수 | 해설 참고            |
| ------ | -------- | ------------- | ---------- | ---------- | --------- | --------- | -------------------- |
| Python |          |               |            |            |           |           |                      |
| Java   | 14060 KB | 120 ms        | O(N)       | O(N)       | 35분      | 1         | :white_large_square: |
| Kotlin |          |               |            |            |           |           |                      |

<br>

### 예외(테스트) 케이스

```
```

