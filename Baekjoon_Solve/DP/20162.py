# 간식 파티(20162번)
####################################################################
    # 문제: https://www.acmicpc.net/problem/20162
    # 다이나믹 프로그래밍(DP)
    # 메모이제이션으로 풀려고 했다가 또 실패했다.
    # 왜 틀렸지 고민하다가 반례를 찾아내서 for문을 활용한 바텀업 DP로 해결하였다.
    # 반례는 N = 4, foods = [1, 3, 2, 3]인 경우이다.
    # 메모이제이션에 적용한 로직으로는 가장 최근에 먹은 간식에 대해서만 고려해서 이 경우 답이 6인데도 불구하고, 4를 출력하고 있었다.
    # 그래서 가장 최근에 먹은 간식이 아니라, 그 동안 먹은 간식 중 현재 간식 평점보다 작은 경우에 저장되어 있는 DP배열의 값이 더 중요하다는 것을 알아냈다.
    # N <= 1000이여서 2중 for문을 돌려도 되는 문제라는 것을 파악했고, 이후에는 큰 고민 없이 풀 수 있었다.
    # 시간 개선을 위해 몇 가지 시도를 해보았지만 8ms밖에 개선하지 못해서 유의미한 개선은 없었다.
####################################################################
import sys
input = sys.stdin.readline

N = int(input())
foods = [int(input()) for _ in range(N)]
dp = [0] * N
dp[0] = foods[0]
ans = 0
for i in range(1, N):
    dp[i] = foods[i] # dp[i]의 초깃값은 foods[i]이다. 왜냐하면 그동안 먹어온 최대 간식 평점 합이 현재 간식보다 작을 수도 있으니 초깃값은 foods[i]로 설정한다.
    for j in range(i):
        if foods[i] > foods[j]: # 현재 간식이 j번째 간식 값보다 클 경우 dp배열의 값을 갱신한다.
            dp[i] = max(dp[i], dp[j] + foods[i])
    ans = max(ans, dp[i]) # 최댓값으로 정답을 갱신한다.
print(ans)
