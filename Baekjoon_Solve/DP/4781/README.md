## [골4] 사탕 가게 (4781번)

https://www.acmicpc.net/problem/4781

### 문제 유형

DP, 배낭 문제(UKP)

<br>

### 어려웠던 점 / 문제의 핵심

소숫점 두자리가 고정이기 때문에 단순히 100을 곱할 생각을 했다가 우연히 질문게시판을 봤는데, 부동소수점 이야기가 나와서 이를 처리하느라 고생하느니 문자열 파싱을 통해 100을 곱해주는 방향으로 구현하였다.

#### 부동 소수점

부동 소수점이란 컴퓨터는 수를 2진수로밖에 표현하지 못하는데 10진수의 소숫점을 표현하다가 발생하는데에서 오는 오차이다.

예를 들면 0.29 * 100 = 28.99999가 되는데, 이러한 오차를 해결하기 위해 적당히 작은 소수(예 - 0.05)를 더한 다음에 int형으로 캐스팅하여 부동 소수점 문제를 해결할 수 있다.



#### Java 문자열 split()

자바에서 문자열 split 함수에서 인자로 받는 값은 단순히 파싱을 위한 기준 문자열의 개념이 아니다.

파이썬의 split 함수는 파싱을 위한 기준 문자열이지만, 자바에서 split 함수는 `Regex(정규식)`을 넣어줘야 한다. 따라서 `.`이라는 문자열을 기준으로 문자열을 파싱하고 싶다면 `.`은 Regex에서 사용하는 특수문자로 가정하기 때문에 `\\.`과 같이 `.` 그 자체로 표현을 해줘야 한다.



#### UKP(Uncapacitated Knapsack Problem)

> 용량 제한 없는 배낭 문제

그 동안의 배낭문제는 각 아이템을 한 개씩만 넣을 수 있는 제한이 있었다. 이를 일반적인 KP문제라고 한다면, `넣을 수 있는 아이템의 제한이 없는 것이 UKP`이다.

일반적인 KP 문제에서는 2차원의 DP를 구성하여 넣을 아이템을 적절히 구성하였지만, 그러한 제한이 없는 UKP 문제에서는 상관 없이 집어 넣을 수 있기 때문에 이전까지 항상 최적의 선택을 해왔다고 보고 1차원의 DP를 구성해서 문제를 해결할 수 있다.

<br>

### 언어별 풀이 요약

| 언어   | 메모리   | 실행 시간(ms) | 시간복잡도 | 공간복잡도 | 풀이 시간 | 시도 횟수 | 해설 참고          |
| ------ | -------- | ------------- | ---------- | ---------- | --------- | --------- | ------------------ |
| Python |          |               |            |            |           |           |                    |
| Java   | 35460 KB | 1120 ms       | O(MN)      | O(M + N)   | 45분      | 1         | :white_check_mark: |
| Kotlin |          |               |            |            |           |           |                    |

<br>

### 예외(테스트) 케이스

```
```

