## [골4] 합분해 2 (13707번)

[https://www.acmicpc.net/problem/13707]()

### 문제 유형

DP

<br>

### 어려웠던 점 / 문제의 핵심

문제는 엄청 간단하다. 0부터 N까지의 정수 K개를 더해서 그 합이 N이 되는 경우의 수를 구하면 된다.

그러면 직관적으로 dp 테이블을 `dp[n][k] = k개의 수를 사용하여 n을 만드는 경우의 수`라고 정의할 수 있다.

그러면 `dp[n][k] = dp[n][k - 1] + dp[n - 1][k - 1] + dp[n - 2][k - 1] + ... + dp[0][k - 1]`임을 쉽게 알아낼 수 있다.

[합분해](https://www.acmicpc.net/problem/2225)의 경우 N, K가 최대 200이기 때문에 O(N ^ 3)으로도 문제를 해결할 수 있다.

그러나 이 문제는 N, K가 최대 5000이기 때문에 O(N ^ 3)으로 문제를 풀 수 없다.

최대 O(N ^ 2)으로 해결해야 한다.

`dp[n][k] = dp[n][k - 1] + dp[n - 1][k - 1] + dp[n - 2][k - 1] + ... + dp[0][k - 1]`이라고 했으니 당연히 `dp[n - 1][k] = dp[n - 1][k - 1] + dp[n - 2][k - 1] + ... + dp[0][k - 1]`이다.

그러면 우리는 `dp[n][k]`를 구하기 위해 `dp[n][k - 1]` 뒤에 나열한 덧셈을 `dp[n - 1][k - 1]`로 치환할 수 있다.

따라서 점화식은 `dp[n][k] = dp[n][k - 1] + dp[n - 1][k - 1]`이다.

이 점화식을 사용하면 O(N ^ 2)으로 문제를 해결할 수 있다.

<br>

### 언어별 풀이 요약

| 언어   | 메모리    | 실행 시간(ms) | 시간복잡도 | 공간복잡도 | 풀이 시간 | 시도 횟수 | 해설 참고            |
| ------ | --------- | ------------- | ---------- | ---------- | --------- | --------- | -------------------- |
| Python |           |               |            |            |           |           |                      |
| Java   | 112864 KB | 356 ms        | O(NK)      | O(NK)      | 30분      | 1         | :white_large_square: |
| Kotlin |           |               |            |            |           |           |                      |

<br>

### 예외(테스트) 케이스

```
```

