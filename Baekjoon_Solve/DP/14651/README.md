## [실1] 걷다보니 신천역 삼 (Large) (14651번)

https://www.acmicpc.net/problem/14651

### 문제 유형

DP

<br>

### 어려웠던 점 / 문제의 핵심

걷다보니 신천역 삼 (Small)과 같은 문제이다. Small을 DP로 풀었다면 Large도 마찬가지로 DP로 풀면 된다.

단, MOD로 나눈 나머지를 구해줘야 하는데,

전체의 합을 MOD로 나눈 나머지와 개별적으로 MOD로 나눈 나머지를 더 한 값은 다르다.

```java
dp[i][0] = dp[i - 1][0] % MOD + dp[i - 1][1] % MOD + dp[i - 1][2] % MOD;
dp[i][1] = dp[i - 1][0] % MOD + dp[i - 1][1] % MOD + dp[i - 1][2] % MOD;
dp[i][2] = dp[i - 1][0] % MOD + dp[i - 1][1] % MOD + dp[i - 1][2] % MOD;
```

이것과

```java
dp[i][0] = (dp[i - 1][0] + dp[i - 1][1] + dp[i - 1][2]) % MOD;
dp[i][1] = (dp[i - 1][0] + dp[i - 1][1] + dp[i - 1][2]) % MOD;
dp[i][2] = (dp[i - 1][0] + dp[i - 1][1] + dp[i - 1][2]) % MOD;
```

이것은 다르다. 아래 점화식으로 해야 올바른 답을 출력한다.

dp의 값을 더하는 도중에 int형을 초과할 수도 있기 때문에 long형인 dp 배열을 선언하고 전부 다 더한 다음에 MOD로 나눈 나머지를 구했다.

<br>

### 언어별 풀이 요약

| 언어   | 메모리   | 실행 시간(ms) | 시간복잡도 | 공간복잡도 | 풀이 시간 | 시도 횟수 | 해설 참고            |
| ------ | -------- | ------------- | ---------- | ---------- | --------- | --------- | -------------------- |
| Python |          |               |            |            |           |           |                      |
| Java   | 15440 KB | 128 ms        | O(N)       | O(N)       | 15분      | 2         | :white_large_square: |
| Kotlin |          |               |            |            |           |           |                      |

<br>

### 예외(테스트) 케이스

```
```

