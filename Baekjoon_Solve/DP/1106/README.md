## [골5] 호텔 (1106번)

https://www.acmicpc.net/problem/1106

### 문제 유형

DP, 배낭 문제

<br>

### 어려웠던 점 / 문제의 핵심

배낭 문제라고 해서 꼭 2차원의 DP를 사용해야 하는 것은 아니다.

어떤 도시에 c1원을 들여서 p1명의 고객이 들어난다면 c1의 배수를 투자했을 때는 p1의 배수만큼 늘어난다.

따라서 배수만큼 마음대로 증가시켜서 선택할 수 있는 구조이기 때문에 C에 도달하기 전까지 N개의 도시 내에서 계속 최솟값을 선택하면 되기 때문에 1차원의 DP 배열로 선언한다.

dp 테이블의 의미는 `dp[i] = i명을 만들기 위한 최소 비용`이다.

dp 배열을 최댓값으로 초기화하고, dp[0] = 0으로 선언한다.

입력으로 주어지는 N개의 도시에 대해서 홍보했을 때 증가하는 인원 수에 대해 최소 비용을 dp 배열에 기록해줘야 한다.

- 이 때, `C`보다 증가하는 인원 수가 더 클 수도 있기 때문에 둘 중 작은 값을 선택해서 해당 인덱스에 최솟값을 갱신시켜준다.

그 후, 1부터 C까지 N개의 도시에 대해서 2중 for문으로 반복해서 C명을 만들기 위한 최소 비용을 구하면 된다. 점화식은 다음과 같다.

```java
for (int c = 1; c < C + 1; c++) {
    for (int n = 1; n < N + 1; n++) {
        Pair pair = pairs[n];
        dp[c] = Math.min(dp[Math.max(c - pair.p, 0)] + pair.c, dp[c]);			
    }
}
```

<br>

### 언어별 풀이 요약

| 언어   | 메모리   | 실행 시간(ms) | 시간복잡도 | 공간복잡도 | 풀이 시간 | 시도 횟수 | 해설 참고            |
| ------ | -------- | ------------- | ---------- | ---------- | --------- | --------- | -------------------- |
| Python |          |               |            |            |           |           |                      |
| Java   | 14320 KB | 140 ms        | O(NC)      | O(C)       | 50분      | 2         | :white_large_square: |
| Kotlin |          |               |            |            |           |           |                      |

<br>

### 예외(테스트) 케이스

```
```

