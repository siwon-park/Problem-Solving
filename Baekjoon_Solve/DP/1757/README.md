## [골4] 달려달려 (1757번)

https://www.acmicpc.net/problem/1757

### 문제 유형

DP, 배낭문제

<br>

### 어려웠던 점 / 문제의 핵심

2차원의 DP로 풀다보니 `쉬었는지 안 쉬었는지 유무`도 값을 계산함에 있어 중요한 정보여서 3차원의 DP로 풀었다.

DP 테이블의 정의는 다음과 같다.

`"i분에 j의 지침지수로 갈 수 있는 최대 거리"`

3차원의 인덱스는 i분째에(혹은 지금) 쉬었느냐, 쉬지 않았느냐를 의미한다.

따라서 `dp[i][0][1]`과 같이 `j = 0`인데 `k = 1`인 경우는 존재하지 않는다. (지침지수가 0인데 i분인 지금 뛰었다는 것은 서로 모순이다.)

굳이 3차원으로 선언하지 않고 `배낭 문제`처럼 2차원의 DP로 풀 수 있는 방법도 존재한다. 2차원의 DP 풀이가 훨씬 더 깔끔하고 빠르다. M번 반복한 다음에 `다시 M번 반복`해서 이전에 지침지수가 `m`이었는데 `연속적으로 쉬어서` 현재 시점인 `i분에 지침지수가 0`이 되어 뛸 수 있는 값들과 비교해서 최댓값을 갱신하는 과정이 한 번 더 필요하다.

```java
int[][] dp = new int[N + 1][M + 1];

for (int i = 1; i <= N; i++) {
    int d = Integer.parseInt(br.readLine());

    dp[i][0] = dp[i - 1][0];
    for (int j = 1; j <= M; j++) {
        dp[i][j] = dp[i - 1][j - 1] + d;
    }

    for (int j = 1; j <= M; j++) {
        if (i - j < 0) break;
        // i - j분에 지침지수가 j이면 j분이 지난 i분에는 지침지수가 0이기 때문에 뛸 수 있다.
        dp[i][0] = Math.max(dp[i][0], dp[i - j][j]);
    }
}
```

2차원의 DP 풀이의 시간 복잡도는 `O(MN + M)`이다.

<br>

### 언어별 풀이 요약

| 언어   | 메모리    | 실행 시간(ms) | 시간복잡도 | 공간복잡도 | 풀이 시간 | 시도 횟수 | 해설 참고          |
| ------ | --------- | ------------- | ---------- | ---------- | --------- | --------- | ------------------ |
| Python |           |               |            |            |           |           |                    |
| Java   | 154120 KB | 520 ms        | O(2MN)     | O(2MN)     | 180분     | 1         | :white_check_mark: |
| Kotlin |           |               |            |            |           |           |                    |

<br>

### 예외(테스트) 케이스

```
```

