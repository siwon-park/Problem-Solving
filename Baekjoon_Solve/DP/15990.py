#1, 2, 3 더하기 5(15990번)
#####################################################
    # 문제: https://www.acmicpc.net/problem/15990
    # 다이나믹 프로그래밍
    # dp 테이블의 i번째 인덱스의 0번째 인덱스에 우리가 찾고자 하는 값을 저장한다.
    # 연속해서 같은 숫자를 두 번 이상 쓸 수 없어서 어려워서 조금 고민하다가 다른 사람의 풀이를 참조하였음
    # dp테이블의 의미는 dp[i][1]은 i를 만들기 위해 마지막에 1을 쓴 경우의 수, dp[i][2]는 i를 만들기 위해 마지막에 2를 쓴 경우, dp[i][3]은 i를 만들기 위해 마지막에 3을 쓴 경우다.
    # 따라서 새로운 숫자 k를 만든다고 가정한다면, 문제의 조건(연속해서 같은 수를 두 번 이상 쓸 수 없음)을 만족하는 점화식은
    # dp[k][1]=dp[k-1][2]+dp[k-1][3]이고, dp[k][2]=dp[k-2][1]+dp[k-2][3], dp[k][3]=dp[k-3][1]+dp[k-3][2]이다.
    # k를 만들 수 있는 경우의 수를 계산한 뒤에 다 더해서 dp[k][0]에 저장한다.
#####################################################
import sys
input=sys.stdin.readline
dp=[[0,0,0,0] for i in range(100001)]
dp[1][1],dp[2][2]=1,1
dp[3][1],dp[3][2],dp[3][3]=1,1,1
dp[1][0],dp[2][0],dp[3][0]=1,1,3
for i in range(4,100001):
    dp[i][1]=(dp[i-1][2]+dp[i-1][3])%1000000009
    dp[i][2]=(dp[i-2][1]+dp[i-2][3])%1000000009
    dp[i][3]=(dp[i-3][1]+dp[i-3][2])%1000000009
    dp[i][0]=(dp[i][1]+dp[i][2]+dp[i][3])%1000000009
T=int(input())
for i in range(T):
    print(dp[int(input())][0])
