## [실5] 피보나치 수 4 (10826번)

https://www.acmicpc.net/problem/10826

### 문제 유형

DP, 큰 수 연산

<br>

### 어려웠던 점 / 문제의 핵심

일단 Java는 메모이제이션으로 풀면 StackOverFlow가 발생하고 연산 OverFlow가 발생한다.

Python의 경우 바텀업 DP 방식으로 연산하면 정수형 연산과정에서 OverFlow가 없으니 큰 무리 없이 풀 수 있다.

문제는 그 외의 언어일 때이다.

dp 배열 전체에 각 값을 저장하는 것이 아니라 2개의 정수형 배열 dp1, dp2를 만들고 각 자리수를 계산하는 개념으로 구현하면 된다. (문자열을 활용하여 각 자리수를 계산하는 방법도 존재한다.)

n이 1만일 때, 피보나치 수의 길이는 2090이니, 넉넉한 크기의 배열을 선언한 다음에, n이 홀수냐 짝수냐에 따라 dp1에 연산 결과를 갱신할지, dp2에 연산 결과를 갱신할지 나눠서 구현하면 된다.

최종 출력은 StringBuilder를 활용해서 전체 문자열을 뒤집어서 출력한다.

<br>

### 언어별 풀이 요약

| 언어   | 메모리   | 실행 시간(ms) | 시간복잡도  | 공간복잡도 | 풀이 시간 | 시도 횟수 | 해설 참고            |
| ------ | -------- | ------------- | ----------- | ---------- | --------- | --------- | -------------------- |
| Python | 34916 KB | 76 ms         | O(N)        | O(N)       | 5분       | 1         | :white_large_square: |
| Java   | 14572 KB | 196 ms        | O(N * 2000) | O(N)       | 30분      | 2         | :white_check_mark:   |
| Kotlin |          |               |             |            |           |           |                      |

<br>

### 예외(테스트) 케이스

```
```

