## [골3] 의리 게임 (28424번)

https://www.acmicpc.net/problem/28424

### 문제 유형

자료 구조, 트리/맵, 분리 집합

<br>

### 어려웠던 점 / 문제의 핵심

union-find를 통해서 다음 번 마실 사람에 대한 정보를 저장하고 빠르게 찾는 것이 핵심이다.

현재 i번 사람이 만취 상태여서 다음 사람에게 넘겨줘야 할 때, 매번 i + 1, i + 2, ..., N까지 확인한다면 비효율적이다.

자신이 만취 상태여서 술을 넘겨야 할 때 마셔야 할 다음 번 사람을 부모라고 하고, 부모 배열에 기록해놓는다면 다음에 마실 사람을 빠르게 찾을 수 있다.

제일 처음에 모든 노드에 대해 자기 자신을 부모라고 정의한다.

그 후 i가 더 이상 마실 수 없을 때, i + 1과 union 연산을 통해 합친다.

그리고 나서 i + 1의 다음 마실 사람인 부모(p)를 찾아 부모가 마실 수 있는지 확인한다.

p도 마실 수 없다면 위에서 했던 로직과 동일하게 p + 1과 union 연산을 하여 다음 마실 사람을 계속해서 찾는다.

이를 현재 남은 섭취량이 0보다 큰 동안 반복한다.  무한 루프 방지를 위해 다음 마실 사람이 N인데 N도 만취상태라면 반복을 종료한다.

<br>

### 언어별 풀이 요약

| 언어   | 메모리   | 실행 시간(ms) | 시간복잡도 | 공간복잡도 | 풀이 시간 | 시도 횟수 | 해설 참고            |
| ------ | -------- | ------------- | ---------- | ---------- | --------- | --------- | -------------------- |
| Python |          |               |            |            |           |           |                      |
| Java   | 63024 KB | 644 ms        | O(QlogN)   | O(N)       | 50분      | 3         | :white_large_square: |
| Kotlin |          |               |            |            |           |           |                      |

<br>

### 예외(테스트) 케이스

```
```

