## [골3] 개구리 점프 (17619번)

https://www.acmicpc.net/problem/17619

### 문제 유형

자료 구조, 정렬, 스위핑, union-find

<br>

### 어려웠던 점 / 문제의 핵심

처음에 좌표 범위가 0 ~ 10^9여서 좌표 압축 + 누적 합으로 푸는 문제인줄 알았는데, 누적합으로는 건너 건너서 갈 수 있는 경우를 찾기가 불가능하다.

따라서 `빠른 좌표순 정렬 + union-find`임을 알 수 있었다.

중요한 점은 `정렬하기 전의 나무의 위치를 기록`해야 한다는 것이다. `쿼리로 들어오는 나무는 입력으로 받은 순서`이기 때문이다.

따라서 만약 겹치는 부분이 없다면 무시하고, 겹치는 부분이 있으면 나무의 원래 위치를 기준으로 union-find를 한다.

그 후 인접한 나무 간의 비교 연산을 통해 최소, 최대 좌표를 갱신한다.

인접한 나무끼리 비교해도 되는 이유는 정렬했기 때문에 굳이 부모를 기준으로 갱신할 필요가 없다. 두 좌표 중 하나는 항상 같은 집합 내에서의 최대 최소를 유지하면서 이동하기 때문이다.

만약 부모를 기준으로 정렬하고자 한다면 정렬한 좌표 상에서 부모의 위치 정보가 필요하기 때문에 추가적으로 다른 자료를 사용해야 해서 메모리적으로 손해이다.

<br>

### 언어별 풀이 요약

| 언어   | 메모리   | 실행 시간(ms) | 시간복잡도       | 공간복잡도 | 풀이 시간 | 시도 횟수 | 해설 참고            |
| ------ | -------- | ------------- | ---------------- | ---------- | --------- | --------- | -------------------- |
| Python |          |               |                  |            |           |           |                      |
| Java   | 77992 KB | 932 ms        | O(NlogN + QlogN) | O(N)       | 50분      | 1         | :white_large_square: |
| Kotlin |          |               |                  |            |           |           |                      |

<br>

### 예외(테스트) 케이스

```
```

