## [골2] 공항 (10775번)

https://www.acmicpc.net/problem/10775

### 문제 유형

자료 구조, 분리 집합, 그리디

<br>

### 어려웠던 점 / 문제의 핵심

Union-Find 유형이라고 되어 있지만, 사실은 그리디에 더 가까운 문제라고 생각한다.

각 i번 비행기별로 최대한 많은 공항에 연결되려면 i번 비행기가 연결할 수 있는 게이트 번호 1 ~ g[i] 중 내림차순으로 높은 순서대로 연결 가능하면 바로 연결하면 된다.

이 문제가 그리디에 더 가까운 이유는 1 ~ g[i]의 게이트 중 하나를 선택할 수 있고, 비행기가 순서대로 도착할 예정이며, 비행기가 어느 게이트에도 도킹할 수 없다면 공항이 폐쇄되고, 이후 어떤 비행기도 도착할 수 없다.고 했으므로 내림차순으로 높은 번호의 게이트에 먼저 연결하는 것이 이득이다.

그런데 이를 2중 for문으로 구현하면 10 ^ 5 x 10 ^ 5 = 10 ^ 10이기 때문에 TLE를 받을 것이 분명하다. 

따라서 다음 연결 가능한 게이트의 최대 번호를 배열에 기록해두는 방식을 사용하면 된다. 

입력 순서대로 들어오는 i번 비행기를 g[i]번 게이트에 연결하고 나면, g[i]의 부모 배열에는 g[i] - 1의 값을 기록해둔다. 그렇게 하면 만약 다음 i + 1번째 이후에 오는 어떤 비행기가 도킹할 수 있는 게이트의 범위가 1 ~ g[i]의 값을 가지고 있다면,  g[i]의 부모에 기록된 게이트 번호(g[i] - 1)로 연결하면 가장 그리디하게 선택할 수 있는 최대의 게이트 번호이고,연결 후에  g[i] - 1의 부모 배열에는 g[i] - 2를 기록해둔다. 이런 식으로 계속 연결하고 나면 (호출한 게이트 번호의 부모 게이트 번호 - 1)을 부모 배열에 기록해둬서 그리디하게 최대한 연결할 수 있도록 하면 된다.

<br>

### 언어별 풀이 요약

| 언어   | 메모리   | 실행 시간(ms) | 시간복잡도 | 공간복잡도 | 풀이 시간 | 시도 횟수 | 해설 참고          |
| ------ | -------- | ------------- | ---------- | ---------- | --------- | --------- | ------------------ |
| Python | 88588 KB | 224 ms        | O(N)       | O(N)       | 60분      | 4         | :white_check_mark: |
| Java   | 29360 KB | 280 ms        | O(N)       | O(N)       | 40분      | 1         | :white_check_mark: |
| Kotlin |          |               |            |            |           |           |                    |

<br>

### 예외(테스트) 케이스

```
```

