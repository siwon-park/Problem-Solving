## [실1] 나무 탈출 (15900번)

https://www.acmicpc.net/problem/15900

### 문제 유형

트리, 그래프 이론, 그래프 탐색, 깊이 우선 탐색

<br>

### 어려웠던 점 / 문제의 핵심

리프에서 루트까지 이르기의 거리 합이 짝수면 아무리 노력해도 이길 수 없기 때문에 `No`를 출력하고, 홀수일 경우에는 이길 수 있기 때문에 `Yes`를 출력하면 된다.

주어지는 입력을 연결 리스트 형태의 그래프로 구성하고, 루트에서 리프까지 이르기의 거리 합을 계산하면 된다.

DFS로 구현해도 되고, BFS로도 구현할 수 있다. 빠른 풀이를 보니까 BFS가 더 효율적인 문제인 것 같다.

추가적으로 리프에서 루트까지 이르는 총 거리 합은 Integer 범위를 벗어나기 때문에 Long형으로 선언해야 한다.

최악의 경우 거리 합은 (N / 2) ^ 2일 수도 있기 때문이다.

- 예를 들어 N = 10일 때, 리프 노드에서 루트까지 거리는 25가 나온다.
- 그러면 최악의 경우 N = 50만이기 때문에 625억이라는 숫자가 나온다. Integer형이 최대 약 21억이니 훨씬 큰 범위이다.

![image](https://github.com/siwon-park/Problem_Solving/assets/93081720/83c8c87c-22c4-4314-a1ff-1d3733bca34c)

<br>

### 언어별 풀이 요약

| 언어   | 메모리    | 실행 시간(ms) | 시간복잡도 | 공간복잡도 | 풀이 시간 | 시도 횟수 | 해설 참고            |
| ------ | --------- | ------------- | ---------- | ---------- | --------- | --------- | -------------------- |
| Python |           |               |            |            |           |           |                      |
| Java   | 203540 KB | 1840 ms       | O(N)       | O(N)       | 30분      | 1         | :white_large_square: |
| Kotlin |           |               |            |            |           |           |                      |

<br>

### 예외(테스트) 케이스

```
```

