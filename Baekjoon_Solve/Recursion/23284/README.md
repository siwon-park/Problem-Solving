## [골5] 모든 스택 수열 (23284번)

https://www.acmicpc.net/problem/23284

### 문제 유형

브루트포스, 백트랙킹, 스택

<br>

### 어려웠던 점 / 문제의 핵심

백트랙킹 + 스택 활용

#### 실수했던 점

도저히 안 풀려서 다른 사람 풀이를 보았고, 올바른 스택 수열인지를 규칙성을 이용해서 백트랙킹으로 구현하였다.

내가 실수했던 점은 두 가지였는데,

가장 큰 실수는 스택에 push하는 순서는 오름차순을 유지한다고 해서 이전에 넣었던 것도 포함해서 유지해야 하는 줄 알고, 사실상 1 ~ N까지 스택에 순서대로 삽입하되 적절한 시점에 뽑아서 구성할 수 있는 모든 수열을 구하고 있었다.

스택에 push하는 순서가 오름차순으로 유지된다는 것은 말 그대로 스택에 집어넣는 숫자는 오름차순을 유지해야 한다.

이 때 정말 중요한 점은 하나 넣고 하나 빼고, 다시 하나 넣고 하나 빼는 경우도 가능하지 않냐고 생각할 수도 있다.

3, 1, 2 순서로 넣고 빼면 [3, 1, 2] 수열을 만들 수 있지 않을까라는 생각이 들겠지만 불가능하다.

즉 스택에 3을 넣었다면 스택에서 숫자를 뽑거나 말거나 그다음에 스택 안에 들어올 수 있는 숫자의 후보는 3보다 큰 숫자이어야 한다는 것이다.

두 번째 실수는 넣을 숫자가 N보다 크면 현재 스택에 있는 것을 모두 뽑아서 수열로 구성하는 로직이었는데, 이 부분은 굳이 해줄 필요가 없었다. 왜냐하면 함수 호출 도중에 스택에서 숫자를 뽑는 과정이 있기 때문에 계속해서 뽑으나 하나씩 하나씩 뽑으나 똑같기 때문이다.

스택 + 백트랙킹의 경우 마지막에 실수로 스택에서 모든 수를 뽑아버리면 함수 호출 종료 후 백트랙킹으로 스택에서 뽑을 숫자가 없어서 에러가 날 수도 있기 때문에 좋은 구현 방법이 아니다.

#### 올바른 풀이

스택을 직접 사용하는 경우, 스택에 push하는 순서는 오름차순이라고 했기 때문에 반드시 스택에  삽입한 수의 순서는 1 ~ N까지 오름차순이어야 한다.

스택에서 뽑는 시점에 따라 수열이 달라지게 되는 개념이다.

따라서 이를 백트랙킹으로 구현하면,

- 스택에서 숫자를 뽑음
- 스택에 숫자를 넣음

이 2가지 경우를 계속 펼쳐나가면 답이다.

<br>

### 언어별 풀이 요약

| 언어   | 메모리   | 실행 시간(ms) | 시간복잡도 | 공간복잡도 | 풀이 시간 | 시도 횟수 | 해설 참고          |
| ------ | -------- | ------------- | ---------- | ---------- | --------- | --------- | ------------------ |
| Python |          |               |            |            |           |           |                    |
| Java   | 26212 KB | 280 ms        | O(10!)     | O(10!)     | 100분     | 1         | :white_check_mark: |
| Kotlin |          |               |            |            |           |           |                    |

<br>

### 예외(테스트) 케이스

```
```

