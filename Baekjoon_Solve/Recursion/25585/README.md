## [골5] 86 ─에이티식스─ 1 (25585번)

https://www.acmicpc.net/problem/25585

### 문제 유형

브루트포스, 백트랙킹

<br>

### 어려웠던 점 / 문제의 핵심

#### 시간 초과 및 DFS 풀이 불가능

- 이 문제를 일반 그래프 탐색 + 백트랙킹으로 풀면 시간초과가 난다. 왜냐하면 고려해야할, 탐색해야할 경우의 수가 너무 많기 때문이다.
- 이 문제는 DFS 탐색으로 풀 수 없다. 왜냐하면 DFS 탐색의 해가 최적임이 보장되지 않는다. 어떤 좌표를 먼저 탐색하느냐에 따라 해가 달라지기 때문이다.

#### 올바른 풀이

- 레기온의 수가 최대 10개이므로 최대 O(10!)의 시간복잡도로 문제를 해결할 수 있다.
- 레기온에 대한 순열을 구하면 이는 경로의 경우의 수를 의미한다.
- 경로들에 대해서 올바른지 유무와 최단 거리를 계산하면 된다.
- 이동할 수 있는 좌표가 정해져 있기 때문에 수학적으로 도작할 수 있는지 유무를 계산할 수 있다.
  - BFS를 통해서 이동할 수 있는 좌표를 구할 수 있다.
  -  (∣*x*1 − *x*2∣ + ∣*y*1 − *y*2∣) % 2; 맨해튼 거리 차이가 홀수인지 짝수인지 판별 → 홀수: 이동 불가, 짝수: 이동 가능
  - (x1 + y1) % 2 == (x2 + y2) %2: 체스판 상에서 같은 색 위치에 있는지 → 체스판 상에서 같은 색이라면 대각선으로 이동이 가능하다.
- 도달 가능하다고 할 때 각 좌표간 거리는 D = max(|x1 - x2|, |y1 - y2|)이다.

<br>

### 언어별 풀이 요약

| 언어   | 메모리   | 실행 시간(ms) | 시간복잡도 | 공간복잡도 | 풀이 시간 | 시도 횟수 | 해설 참고          |
| ------ | -------- | ------------- | ---------- | ---------- | --------- | --------- | ------------------ |
| Python |          |               |            |            |           |           |                    |
| Java   | 16848 KB | 648 ms        | O(N^2)     | O(N^2)     | 80분      | 6         | :white_check_mark: |
| Kotlin |          |               |            |            |           |           |                    |

<br>

### 예외(테스트) 케이스

```
```

