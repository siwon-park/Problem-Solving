# 휴게소 세우기(1477번)
###########################################################################################
    # 문제: https://www.acmicpc.net/problem/1477
    # 이분탐색, 매개변수 탐색
    # 휴게소가 없는 구간의 최댓값을 mid로 두고 최소인 mid를 찾으면 된다.
    # 가장 긴 구간이 있다고 할 때, 해당 구간 안에 2개나 그 이상의 휴게소를 지을 수도 있다.
    # 또한, 구간의 개념이므로 반드시 고속도로의 출발점인 0과 끝나는 점인 L을 배열에 포함시켜야한다. 따라서 배열의 길이는 N + 2가 된다.
    # 구간 안에 짓는 휴게소의 수를 구하는 방법은 해당 구간을 mid 값으로 나눈다고 보면 된다.
    # 단 이때, 구간 안에 짓는 휴게소의 개수를 구하는 공식은 (lst[i] - lst[i - 1])을 mid로 나눈 몫이 아니라, 나눈 값에서 올림한 다음 - 1을 해준 값이다.
    # 당연하게도 그 이유는 선을 N(등)분 했을 때 생기는 지점은 N - 1개이기 때문이다.
    # 몫이 안 되는 이유는 예를 들어, 구간의 길이가 600이라고 하고, mid값이 200라고할 때, 600 // 200은 3이지만, 실제 지을 수 있는 휴게소 수는 2개이기 때문이다.
    # 따라서 나눈 값을 올림한 다음에 1을 빼줘야 한다.
    # cnt <= M일 때, mid 값을 줄여서 탐색하는데, mid 값을 줄이게 되면 나누는 구간이 많아지므로 cnt는 늘어나게 된다.
    # 그러면 cnt가 늘어나서 M보다 커지면 다시 mid 값을 늘려서 탐색하므로, 결국 cnt <= M을 만족하는 최대 길이 구간의 최솟값을 찾게 되는 것이다.
###########################################################################################
import sys, math
input = sys.stdin.readline

N, M, L = map(int, input().split())
lst = [0] + list(map(int, input().split())) + [L]
lst.sort()


def binary_search():
    opt = 0
    s, e = 1, lst[-1] - lst[0]
    while s <= e:
        mid = (s + e) // 2
        cnt = 0
        for i in range(1, N + 2):
            cnt += math.ceil((lst[i] - lst[i - 1]) / mid) - 1  # cnt += (lst[i] - lst[i - 1]) // mid
        if cnt <= M:
            e = mid - 1
            opt = mid
        else:
            s = mid + 1
    return opt


print(binary_search())
