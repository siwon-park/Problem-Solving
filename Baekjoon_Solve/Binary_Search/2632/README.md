## [골2] 피자판매 (2632번)

https://www.acmicpc.net/problem/2632

### 문제 유형

누적 합, 이분 탐색

<br>

### 어려웠던 점 / 문제의 핵심

원형 피자에서 `나올 수 있는 연속된 부분 합(누적합)`을 모두 구한 다음에 이분 탐색으로 문제를 해결하였다.

`찾고자 하는 값 - 피자 A의 연속된 부분합`이 `피자 B의 연속된 부분 합에 있는지 확인`하여 그 개수를 구하면 된다.

이는 `lower bound`와 `upper bound`의 개념을 통해 찾을 수 있다.

`n`과 `m`이 최대 1000이기 때문에 최악의 경우를 가정해도 `n^2 - n + 2`개이다.

왜냐하면 `피자 조각 한 개`를 고른 다음에 `피자 조각의 수 - 1`만큼 나올 수 있는 누적 합을 구하면 `n(n - 1)`개이다. 그 후 `전체 피자의 합 1개`와 `해당 피자에서 조각을 고르지 않는 경우 1개(=0)`를 더해주기 때문에 2를 더해주는 것이다.

#### 내가 실수했던 점 1

아무 생각 없이 주어지는 피자 조각의 값을 정렬하여 누적 합을 구하고 있었다. 문제에서 시계 방향 순으로 주어진다고 했지, 크기 순으로 주어진다고 하지는 않았다. 문제를 잘못 읽어서 이렇게 됐다.

#### 내가 실수했던 점 2

문제에서 `한 종류의 피자를 2 조각 이상 판매할 때는 반드시 연속된 조각들을 잘라서 판매`한다고 했으므로 누적 합의 개념을 사용해야 하는 것은 알았는데, 중요한 것은 `원형`인 것을 잊은 채 누적 합을 구하고 있었다.

즉, 입력으로 받을 때부터 `피자 크기의 2배`의 사이즈를 가진 배열을 선언한 다음에

`pizzaA[i] = pizzaA[i + M]`이런 방식으로 원형 처럼 계산이 가능한 배열을 만들어줘야 했다.

<br>

### 언어별 풀이 요약

| 언어   | 메모리   | 실행 시간(ms) | 시간복잡도      | 공간복잡도    | 풀이 시간 | 시도 횟수 | 해설 참고            |
| ------ | -------- | ------------- | --------------- | ------------- | --------- | --------- | -------------------- |
| Python |          |               |                 |               |           |           |                      |
| Java   | 89320 KB | 612 ms        | O(N^2 * logM^2) | O(N^2 + M^ 2) | 90분      | 2         | :white_large_square: |
| Kotlin |          |               |                 |               |           |           |                      |

<br>

### 예외(테스트) 케이스

```
```

