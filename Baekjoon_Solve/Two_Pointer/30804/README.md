## [실2] 과일 탕후루 (30804번)

https://www.acmicpc.net/problem/30804

### 문제 유형

구현, 투 포인터, 브루트포스

<br>

### 어려웠던 점 / 문제의 핵심

과일을 앞이나 뒤에서만 뺄 수 있다는 점에서 투 포인터로 문제를 해결 가능함을 어느 정도 알 수 있다.

우리가 찾는 것은 과일 종류 수가 2개 이하인 부분 배열의 최대 크기(길이)를 찾는 것이다.

- 시작 포인터(s): s가 오른쪽으로 가면 맨 앞의 과일을 빼는 셈이다.
- 끝 포인터(e): e가 오른쪽으로 가면 맨 뒤에 과일을 꽂는 셈이다.

이렇게 했을 때 과일을 결국 앞 혹은 뒤에서만 추가/삭제하는 것이 된다.

그러면 아래와 같은 방법으로 포인터를 이동하면서 길이 최댓값을 찾으면 된다.

- N = 1이면 최댓값은 1이다.
- 현재 최대 길이 = 2, s = 0, e = 1에서 시작. s < e < N인 동안 반복한다.
  - 과일의 종류는 카운트 배열을 활용하되, 현재 과일의 수가 2이면 종류는 1개이고 그 외에는 2개다.
- 현재 과일 종류가 2개 이하면 끝 포인터를 옮긴다.
  - 현재 포인터 정보를 활용하여 e - s + 1과 현재 최댓값을 비교하여 최댓값을 갱신한다.
  - 끝 포인터 e를 오른쪽으로 이동하여 길이를 늘려본다.
  - 현재 끝 포인터에 존재하는 과일 개수를 1개 증가시키고, 증가시킨 후 그 수가 1이라면 종류가 1개 추가된 것이므로 종류 수를 증가시킨다.
- 현재 과일 종류가 2개 초과면 시작 포인터를 옮긴다.
  - 현재 시작 포인터 위치에 있는 과일 종류를 1개 감소시키고, 감소시킨 후 그 수가 0이라면 종류가 1개 감소된 것이므로 종류 수를 감소시킨다.
  - 시작 포인터를 오른쪽으로 옮긴다.

<br>

### 언어별 풀이 요약

| 언어   | 메모리   | 실행 시간(ms) | 시간복잡도 | 공간복잡도 | 풀이 시간 | 시도 횟수 | 해설 참고            |
| ------ | -------- | ------------- | ---------- | ---------- | --------- | --------- | -------------------- |
| Python | 34600 KB | 256 ms        | O(N)       | O(N)       | 25분      | 1         | :white_large_square: |
| Java   |          |               |            |            |           |           |                      |
| Kotlin |          |               |            |            |           |           |                      |

<br>

### 예외(테스트) 케이스

```

```

