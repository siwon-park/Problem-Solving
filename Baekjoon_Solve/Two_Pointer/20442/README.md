## [골3] ㅋㅋ루ㅋㅋ(20442번)

https://www.acmicpc.net/problem/20442

### 문제 유형

투 포인터

<br>

### 어려웠던 점 / 문제의 핵심

ㅋㅋ루ㅋㅋ문자열은 `R`로만 이루어져있거나, `R`로만 이루어진 문자열 양 끝에 `K`의 쌍들이 존재하는 문자열이다.

즉, `R`과 `R`사이에는 K가 올 수 없다.

결국에는 `가장 긴 R로만 이루어진 문자열의 길이` + `K의 쌍 x 2`가 가장 긴 ㅋㅋ루ㅋㅋ문자열이다.

이 때 K의 쌍은 양 끝이 균형을 이루어야 하기 때문에 왼쪽 K와 오른쪽 K 중 더 작은 값을 택하면 된다.

현재 R의 왼쪽에 존재하는 K의 누적 개수와 현재 R의 오른쪽에 존재하는 K의 누적 개수를 구한다. (코드 상으로는 오른쪽 K의 누적은 리스트를 반전시켜줘야 한다.)

배열을 사용하지 않고 리스트를 사용하는 것이 이득이다. 배열을 사용하는 것은 낭비이다. 왜냐하면 리스트를 사용하면 입력으로 주어진 문자열 상에서 R의 개수를 리스트의 인덱스만으로 계산할 수 있다. (리스트의 인덱스가 의미하는 것이 R의 위치이기 때문)

이후 투 포인터를 통해 위에서 언급한 산식으로 가장 긴 ㅋㅋ루ㅋㅋ문자열을 구하면 된다.

<br>

### 언어별 풀이 요약

| 언어   | 메모리    | 실행 시간(ms) | 시간복잡도 | 공간복잡도 | 풀이 시간 | 시도 횟수 | 해설 참고          |
| ------ | --------- | ------------- | ---------- | ---------- | --------- | --------- | ------------------ |
| Python |           |               |            |            |           |           |                    |
| Java   | 139392 KB | 476 ms        | O(N)       | O(N)       | 45분      | 1         | :white_check_mark: |
| Kotlin |           |               |            |            |           |           |                    |

<br>

### 예외(테스트) 케이스

```
```

