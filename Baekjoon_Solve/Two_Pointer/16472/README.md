## [골4] 고냥이 (16472번)

https://www.acmicpc.net/problem/16472

### 문제 유형

투 포인터

<br>

### 어려웠던 점 / 문제의 핵심

단어 등장 빈도 수에 따라서 투 포인터를 옮기는 형태로 구현하면 된다.

2개의 풀이가 있는데, 하나는 for + while 구문을 조합한 것이고, 다른 하나는 while문만 사용한 것이다.

for + while 문을 섞은 풀이의 경우, for 구문으로 s = 0에서 출발해서 e를 while문을 통해서 조건을 만족하는 동안 계속 오른쪽으로 밀고, 갱신하니 e가 M에 더 빨리 도착할 수 있어 사실상 연속 문자열의 최대 길이를 더 빨리 구하게 되니, 조금 더 빠를 수 밖에 없는 것 같다.

while 문만 사용한 풀이의 경우 s = -1에서 출발하고, e = 0에서 출발하는데 어차피 문제 조건에서 N이 1보다 크다고 했기 때문에, 최대 길이를 갱신할 때 처음부터 e - s + 1로 해도 어차피 최소 연속 부분 문자열의 길이는 2 이상이어서 잘못된 답을 구할 가능성은 없다.

- 처음에 현재 문자열의 실제 길이가 1이더라도 2로 최장 길이를 갱신하는데(0 - (-1) + 1 = 2), 어차피 문제 조건에 맞는 최소 연속 부분 문자열의 길이는 2이상이다. 따라서 상관 없다.

<br>

### 언어별 풀이 요약

- while문만 사용한 풀이의 경우 시간 복잡도는 244ms이다.

| 언어   | 메모리   | 실행 시간(ms) | 시간복잡도 | 공간복잡도 | 풀이 시간 | 시도 횟수 | 해설 참고            |
| ------ | -------- | ------------- | ---------- | ---------- | --------- | --------- | -------------------- |
| Python |          |               |            |            |           |           |                      |
| Java   | 15556 KB | 160 ms        | O(M)       | O(N)       | 60분      | 5         | :white_large_square: |
| Kotlin |          |               |            |            |           |           |                      |

<br>

### 예외(테스트) 케이스

```
```

