## [골4] 생일 선물 (12892번)

https://www.acmicpc.net/problem/12892

### 문제 유형

정렬, 투 포인터

<br>

### 어려웠던 점 / 문제의 핵심

문제에 대한 큰 풀이 흐름은 가격에 대해서 정렬한 다음에 양 끝의 선물 간 가격 차를 기준으로 두 포인터를 움직이면 된다.

우선 그동안 풀었던 투 포인터랑 큰 틀은 비슷하지만 세부적인 측면에서 아주 살짝 달라서 당황했고, 풀고나니 골드 4라 더 당황했다.

이 문제의 경우 특정 위치의 선물 한 개만 골랐을 때의 경우를 어떻게 구현하느냐가 로직 구현의 핵심인 것 같다.

왜냐하면 특정 위치의 선물 단 한 개만 고른다면 가격 차는 0이고, 만족도는 해당 선물의 만족도이기 때문이다.

또한 이 값이 최대가 될 수도 있어서 더 그렇다.

그래서 투 포인터의 시작을 둘 다 `0`으로 시작하고, `s <= e && e < N`인 동안 반복해야 한다. `s`와 `e`의 차이가 항상 1이 나게 한다면 특정 위치의 선물 한 개만 고르는 경우를 고려하지 못하기 때문이다.

선물의 합은 Integer형을 벗어날 수 있기 때문에 long형으로 선언해야 하고, 마치 LinkedList처럼 양 끝에 e 위치의 선물 가치를 붙이고 s위치의 선물 가치를 떼는 방식으로 합을 계산하면 된다.

-  s <= e && e < N인 동안
- 만약, e 위치의 선물의 가격과 s 위치의 선물 가격 차이가 `D 미만`이라면
  - `현재 선물의 총 가치 += e 위치의 선물의 가치`를 해준다.
    - e 위치의 선물만 더해줘도 상관 없는게, 처음 s와 e가 둘 다 0에서 출발했기 때문에 가격 차이는 무조건 D 미만일 수 밖에 없고, 선물 가치 합의 초깃값은 0이기 때문에 e만 더 해줄 경우 정확히 현재 위치의 선물 한 개만 고른 상태를 반영하는 것이 된다.
    - 또한 `s <= e`인 동안 반복하기 때문에 `s == e`인 시점에는 가치 합이 0이겠지만, 역시 선물 가격 차가 D미만임을 항상 만족하기 때문에 e를 한 칸 오른쪽으로 옮기면 해당 위치의 선물 한 개를 고른 경우를 반영할 수 있다.
    - 그리고 `e < N`인 동안 반복하기 때문에 마지막 위치의 선물 가격도 값을 먼저 더한 다음에 e를 오른쪽으로 밀고, 최댓값 갱신을 가장 아랫부분에서 해줘서 마지막 위치의 선물 한 개를 고른 경우도 정확히 반영할 수 있는 것이다. 
  - e를 1칸 오른쪽으로 옮겨준다.
- 양 끝 선물 가격 차이가 `D 이상`이라면
  - `현재 선물의 총 가치 -= s 위치의 선물 가치`를 해준다.
  - s를 1칸 오른쪽으로 옮겨준다.
- 현재 선물의 총 가치와 최댓값 중에 더 큰 값을 최댓값으로 갱신시켜준다.

<br>

### 언어별 풀이 요약

| 언어   | 메모리   | 실행 시간(ms) | 시간복잡도 | 공간복잡도 | 풀이 시간 | 시도 횟수 | 해설 참고            |
| ------ | -------- | ------------- | ---------- | ---------- | --------- | --------- | -------------------- |
| Python |          |               |            |            |           |           |                      |
| Java   | 44776 KB | 580 ms        | O(N)       | O(N)       | 30분      | 1         | :white_large_square: |
| Kotlin |          |               |            |            |           |           |                      |

<br>

### 예외(테스트) 케이스

```
```

