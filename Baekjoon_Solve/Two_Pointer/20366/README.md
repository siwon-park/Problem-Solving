## [골3] 같이 눈사람 만들래? (20366번)

https://www.acmicpc.net/problem/20366

### 문제 유형

투 포인터

<br>

### 어려웠던 점 / 문제의 핵심

포인터를 어떻게 두고 문제를 풀어야 할지 많이 고민했던 문제이다.

#### 어려웠던 점

눈 사람을 만들기 위해서는 작은 수 2개와 큰 수 2개를 구성해야 한다.

이 때 내가 했던 실수이자, 헤맸던 부분이 투 포인터를 사용하기 위해 4개의 수 중 2개의 수는 고정을 해야했는데, 작은 수 2개를 고정하였다.

즉, 눈사람의 머리를 고정으로 하였는데 이렇게 하면 문제가 생긴다.

왜냐하면 머리를 고정했으니 두 포인터가 가르키는 값은 몸통인데, `left`를 엘자의 몸통, `right`를 안나의 몸통이라고 했을 때 눈사람 높이의 차이의 절댓값을 최소화하기 위해서 포인터를 옮기는 기준이 명확하지 않기 때문이다.

즉, `left`를 옮기면 값이 증가하는데, 그럼 차이의 절댓값은 커질 수 밖에 없다. 또한 `right`를 옮기면 어느 한쪽 눈사람의 높이가 줄어들기 때문에 절댓값은 증가한다. 포인터를 어디로 옮기더라도 최적값을 찾기 힘들 수 있다.

#### 올바른 접근법

부위를 나눠서 고정할 것이 아니라, 어느 한쪽의 눈사람 높이를 고정하는 것이 올바른 접근법이다.

`i`, `j`를 고정된 눈사람의 높이 합으로 보고, `left`를 다른 눈사람의 머리, `right`를 다른 눈사람의 몸통으로 가정한다.

![image](https://github.com/siwon-park/Problem_Solving/assets/93081720/bacedd9d-b2c5-4b0f-a9c1-ae0f4e2cff9d)

만약에 두 눈사람 높이 차이가 0보다 크면 반대편 눈사람의 크기를 늘려야 하니 `left`를 늘린다.

만약 높이 차이가 0보다 작으면 다른 눈사람의 크기를 줄여야 하니 `right`를 줄인다.

##### Python 기준

Python3 기준으로 Java 풀이와 똑같이 풀면 시간초과 판정을 받는다. Pypy3로는 통과함.

Python3로도 통과를 하려면 함수형으로 만든 다음, 두 눈사람의 차이가 0일 경우 더 이상 탐색하지 않고 0을 바로 return하게끔 구현하면 그나마 빨라진다.

더욱 빠른 풀이들이 있는데, 미리 전처리를 하고 조건문을 활용하는 방식이었다. 투 포인터라는 큰 범주는 같았음.

<br>

### 언어별 풀이 요약

| 언어   | 메모리   | 실행 시간(ms) | 시간복잡도 | 공간복잡도 | 풀이 시간 | 시도 횟수 | 해설 참고            |
| ------ | -------- | ------------- | ---------- | ---------- | --------- | --------- | -------------------- |
| Python | 31256 KB | 2196 ms       | O(N ^ 3)   | O(N)       | 30분      | 3         | :white_large_square: |
| Java   | 14636 KB | 368 ms        | O(N ^ 3)   | O(N)       | 60분      | 1         | :white_check_mark:   |
| Kotlin |          |               |            |            |           |           |                      |

<br>

### 예외(테스트) 케이스

```
```

