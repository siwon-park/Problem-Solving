## [골5] 두 개의 탑 (2118번)

https://www.acmicpc.net/problem/2118

### 문제 유형

누적 합, 두 포인터

<br>

### 어려웠던 점 / 문제의 핵심

주어진 탑들의 위치가 원형이고, 각 지점들 사이의 거리가 주어지기 때문에 누적합의 개념을 이용해야 한다. 두 탑의 거리 중 최댓값은 시계, 반시계 방향 경로의 길이 중 최솟값이다. 

처음에는 정방향 누적합, 역방향 누적합을 계산하여 문제를 접근하려 했으나, 생각해보니 어차피 지름이 `R`로 고정되어 있기 때문에 `역방향의 길이 = R - 정방향의 길이`이다. 

또한 원형을 생각해서 마지막 위치의 점에서 출발하는 것을 고려해 배열의 길이를 N * 2로 선언했었는데, 마찬가지로 어차피 두 지점을 골랐을 때 반대 방향의 경로 길이는 R에서 정방향의 길이를 뺀 것이기 때문에 굳이 2배로 선언할 필요가 없었다.

이렇게 설계하고도 2번 틀렸습니다를 받았는데, 분명 포인터를 땡기고 미는 부분이 잘못되었을 가능성이 매우 높았다. 아쉽게도 첫 코드의 반례는 찾았는데, 두 번째 코드의 반례는 찾지 못했다. 역시 두 포인터는 아직 나에게 조금 어려운 것 같다. 포인터를 언제 땡기고 밀어야 할지 감이 잘 잡히지 않는다. 

그렇게 맞왜틀을 외치다가, `R`이 고정이라면 `반지름의 내림값인 R / 2`도 고정일 것이고, 우리가 `찾고자 하는 최댓값은 결국 R / 2와 최대한 가까운 값`이라는 것을 파악해냈다.

따라서 두 포인터의 이동 조건이 되는 값을 `half(= R / 2)`로 잡고 현재 두 탑 간의 거리가 `half 이상이면 시작 포인터 s를 옮겨서 길이를 줄이고, half 미만이면 끝 포인터 e를 밀어서 길이를 늘리는 방식`으로 포인터를 이동시켰다. 포인터 이동 간 두 지점의 시계 방향, 반 시계 방향의 경로 중 작은 값의 최댓값을  기록하였고, 이를 출력하면 정답이다.

<br>

### 언어별 풀이 요약

| 언어   | 메모리   | 실행 시간(ms) | 시간복잡도 | 공간복잡도 | 풀이 시간 | 시도 횟수 | 해설 참고            |
| ------ | -------- | ------------- | ---------- | ---------- | --------- | --------- | -------------------- |
| Python |          |               |            |            |           |           |                      |
| Java   | 19888 KB | 220 ms        | O(N)       | O(N)       | 60분      | 3         | :white_large_square: |
| Kotlin |          |               |            |            |           |           |                      |

<br>

### 예외(테스트) 케이스

```
```

