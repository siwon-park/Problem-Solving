## [골3] 세 용액 (2473번)

https://www.acmicpc.net/problem/2473

### 문제 유형

정렬, 이분 탐색, 투 포인터

<br>

### 어려웠던 점 / 문제의 핵심

느린 언어를 사용하여 이분 탐색으로 접근하면 시간 초과가 날 수 있다.

N의 크기가 최대 5000이기 때문에 `O(N ^ 2 * logN)`이기 때문에 3억 이상의 수가 나온다.

따라서 안정적으로 `O(N ^ 2)`으로 풀 수 있는 방법을 선택해야 한다.

그래서 투 포인터 풀이가 보다 적절한 접근 방법이다.

`i`, `left`, `right`를 둔다. 단, `i < N - 2`이고 `i + 1 <= left`이며, `right <= N - 1`이다.

찾고자 하는 값은 세 수의 합이 0과 가까운 수이기 때문에, `세 수의 절댓값이 가장 작은 조합`을 찾으면 된다.

그리고 `left`를 오른쪽으로 옮기게 되면 세 수의 값 자체가 증가하고, `right`를 왼쪽으로 증가시키면 세 수의 값 자체가 감소한다.

여기서 정말 중요한 것은 `세 수의 합 자체`를 포인터를 옮기는 조건으로 사용해야 하지, `세 수의 합의 절댓값`을 포인터를 옮기는 조건으로 사용하면 안 된다.

왜냐하면 음수가 있기 때문에 극단적인 경우에 오른쪽 포인터인 `right`를 왼쪽으로 옮겼을 때, 절댓값이 감소하지 않고 오히려 증가하는 경우가 나올 수도 있기 때문이다.

<br>

### 언어별 풀이 요약

| 언어   | 메모리   | 실행 시간(ms) | 시간복잡도 | 공간복잡도 | 풀이 시간 | 시도 횟수 | 해설 참고          |
| ------ | -------- | ------------- | ---------- | ---------- | --------- | --------- | ------------------ |
| Python |          |               |            |            |           |           |                    |
| Java   | 17304 KB | 264 ms        | O(N ^ 2)   | O(N)       | 60분      | 4         | :white_check_mark: |
| Kotlin |          |               |            |            |           |           |                    |

<br>

### 예외(테스트) 케이스

```
```

