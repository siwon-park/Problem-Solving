## [골4] 합이 0 (3151번)

https://www.acmicpc.net/problem/3151

### 문제 유형

브루트포스, 정렬, 이분 탐색, 투 포인터

<br>

### 어려웠던 점 / 문제의 핵심

N의 최댓값이 1만이기 때문에 이분 탐색보다는 투 포인터로 접근하는 것이 보다 효율적이다.

시간 제한이 널널한 편이라 이분 탐색으로도 풀 수 있다.

정렬한 다음에 for 구문을 순회하면서 하나의 인덱스만 고정하고, `left`, `right`인덱스를 만든다.

그 후 `left < right`인 동안 아래 과정을 반복한다.

- 세 수의 합이 `0`일 경우
  - 만약에 `left`위치의 수와 `right`위치의 수가 같다면
    - 정렬된 상태이기 때문에 `left`부터 `right`에 이르기까지 모든 수가 같다.
    - 따라서 그 사이의 숫자에서 2개를 고르는 조합의 경우와 같다.
  - `left`위치의 수와 그 다음 left인 `left + 1 `의 수가 같다면
    - `left`를 증가시키고, 왼쪽이 같은 개수인 `l_cnt`를 1 증가시킨다.
  - `right`위치의 수와 그 다음 right인 `right - 1 `의 수가 같다면
    - `right`를 증가시키고, 오른쪽이 같은 개수인 `r_cnt`를 1증가시킨다.
  - 그 후 `l_cnt`에서 1개 고르는 경우와 `r_cnt`에서 1개 고르는 경우의 수인 `l_cnt * r_cnt`를 정답에 더 해준다.
- 세 수의 합이 `0` 초과일 경우
  - `right`를 1 감소
- 세 수의 합이 `0` 미만일 경우
  - `left`를 1 증가

<br>

### 언어별 풀이 요약

이 문제 파이썬3 1등은 200ms대이고, 2등은 5000ms대이다. 1등의 풀이를 한 번 보고 싶은 문제이다.

| 언어   | 메모리   | 실행 시간(ms) | 시간복잡도 | 공간복잡도 | 풀이 시간 | 시도 횟수 | 해설 참고          |
| ------ | -------- | ------------- | ---------- | ---------- | --------- | --------- | ------------------ |
| Python | 32276 KB | 12520 ms      | O(N ^ 2)   | O(N)       | 40분      | 1         | :white_check_mark: |
| Java   | 18228 KB | 420 ms        | O(N ^ 2)   | O(N)       | 60분      | 5         | :white_check_mark: |
| Kotlin |          |               |            |            |           |           |                    |

<br>

### 예외(테스트) 케이스

```
```

