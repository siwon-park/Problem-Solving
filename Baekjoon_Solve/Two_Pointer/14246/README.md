## [실2] K보다 큰 구간 (14246번)

https://www.acmicpc.net/problem/14246

### 문제 유형

두 포인터, 누적 합

<br>

### 어려웠던 점 / 문제의 핵심

주어진 수열을 가지고 누적 합 배열을 만든다.

만약 어떤 위치에서 누적 합의 차이(구간 합)를 `arr[e] - arr[s]`라고 할 때, 이 값이 k보다 크면 `e` 이후의 인덱스 부터는 계속해서 k보다 클 수밖에 없다.

따라서 구간 합이 k이하일 때는 `e`를 계속해서 증가시키다가 k보다 커지면 `n - e + 1`만큼 쌍의 개수를 더해준다.

또한 구간 합이 k보다 커지면 `s`를 1 증가시켜준다.

#### 문제의 핵심

`s <= e && e <= n`인 동안 반복해준다. `s <= e`인 이유는 아래와 같은 테스트 케이스에서 원소 하나가 이미 k보다 큰 경우가 있는 케이스를 고려해야 하기 때문이다.

```
2
2 2
1
```

여기서 누적 합은 `[0, 2, 4]`이고, 만약 s < e라면 arr[1] - arr[0], arr[2] - arr[0]만 고려하여 2가 출력된다. 그러나 사실 정답은 arr[1] - arr[0], arr[2] - arr[0], arr[2] - arr[1]로 총 3개이다.

그래서 `s <= e`인 경우까지 모두 고려해줘야 한다. s의 초깃값이 0, e의 초깃값이 1이고 어차피 구간 합이 k보다 크지 않으면 e를 옮기기 때문에 s > e인 경우는 나오지 않을 것이다.

그럼 s < e로 하고, 구간 합이 k보다 클 때 s와 e를 동시에 옮기는 방법은 어떨까라고 생각할 수도 있겠지만, 일단 직접 해보니까 1%에서 바로 틀렸습니다 판정을 받는다. 또한 잘 생각해보면 방법 자체도 잘못된 방법이다.

이렇게 구현하면 구간 합이 k보다 큰 올바른 쌍을 찾을 수 없다. 왜냐하면 동시에 옮겼기 때문에 s는 그대로인데, e만 더 커졌을 때 구간 합의 크기가 k보다 커서 조건을 만족하는 쌍의 경우를 전부 스킵하기 때문에 그렇다.

따라서 올바른 반복 조건은 `while (s <= e && e <= n)`이다.

<br>

### 언어별 풀이 요약

| 언어   | 메모리   | 실행 시간(ms) | 시간복잡도 | 공간복잡도 | 풀이 시간 | 시도 횟수 | 해설 참고            |
| ------ | -------- | ------------- | ---------- | ---------- | --------- | --------- | -------------------- |
| Python |          |               |            |            |           |           |                      |
| Java   | 22344 KB | 288 ms        | O(N)       | O(N)       | 35분      | 3         | :white_large_square: |
| Kotlin |          |               |            |            |           |           |                      |

<br>

### 예외(테스트) 케이스

```
```

