## [골5] 회문 (17609번)

[https://www.acmicpc.net/problem/17609]()

### 문제 유형

투 포인터

<br>

### 어려웠던 점 / 문제의 핵심

#### 잘못된 접근법

- 두 포인터 위치의 문자열이 같으면 `s += 1`, `e -= 1`로 두 포인터 모두 옮긴다.
- 두 포인터 위치의 문자열이 다를 경우
  - 만약 s += 1을 했을 때 e 위치의 문자열과 같다면 s를 옮긴다.
  - 그게 아니라, e -= 1을 했을 때 s 위치의 문자열과 같다면 e를 옮긴다.

위의 접근법은 `abccbca`와 같이 s = 1, e = 5일 때, 예외가 발생한다.

왜냐하면 특정 시점부터 `그리디`하게 탐색하게 되는 것과 같아 최적해가 아니게 된다.

따라서 `재귀`로 `s + 1, e인 경우`와 `s, e - 1`로 `분기 처리해서 탐색`해야 한다.

탐색 시, s < e인 동안 탐색하면 된다.

s <= e가 아닌 이유는 `aca`와 같이 가운데만 다른 길이가 홀수인 회문이 존재하기 때문.

RecursionError와 시간초과를 피하기 위해 flag 변수를 사용하였다.

처음엔 flag 변수를 사용하지 않아서 RecursionError 및 시간초과가 났는데, flag 변수를 통해 쓸데 없이 재귀호출을 하는 경우를 피해야 한다.

sys로 재귀 호출 제한을 풀더라도 시간초과를 피하긴 힘들다.

flag가 True인 상태에서 재귀로 탐색을 시작하는 순간 일단 최소 유사 회문이고 이때부터 flag를 False로 변경해서 재귀호출을 시작한다.

만약에 flag가 False인 상태인데, 두 포인터 위치의 문자열이 다를 경우엔 일반 문자열 확정이므로 더 이상 호출할 필요 없이 2를 계속 반환하면 된다.

<br>

### 언어별 풀이 요약

| 언어   | 메모리   | 실행 시간(ms) | 시간복잡도 | 공간복잡도 | 풀이 시간 | 시도 횟수 | 해설 참고          |
| ------ | -------- | ------------- | ---------- | ---------- | --------- | --------- | ------------------ |
| Python | 31388 KB | 180 ms        | O(N)       | O(N)       | 50분      | 4         | :white_check_mark: |
| Java   |          |               |            |            |           |           |                    |
| Kotlin |          |               |            |            |           |           |                    |

<br>

### 예외(테스트) 케이스

```
abccbca
```

