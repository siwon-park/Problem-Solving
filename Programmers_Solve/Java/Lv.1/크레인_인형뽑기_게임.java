// level - 1 크레인 인형뽑기 게임(2019 카카오 개발자 겨울 인턴십)
/////////////////////////////////////////////////////////////
  // java에서 처음으로 스택 자료 구조형을 사용해서 풀어보았다.
  // 사실 어제 풀다가 도저히 안 풀려서 포기했던 문제였고, 그 때는 스택 자료형은 아니지만, 배열과 포인터를 이용해 스택과 유사하게 구현했으나
  // 자꾸 27.3점으로 대부분 틀렸다.
  // 사실 오늘도 스택을 사용해서 구현했지만, 어제와 비슷했다. 몇 번 시도 끝에 그 이유를 알 수 있었다.
  // 인형을 뽑고 나서 해당 위치에 있는 인형의 숫자를 0으로 바꿔줘야 했는데, 스택에 푸시할 때만 그렇게 처리해주고 있었다.
  // 연속적인 인형일 경우 스택에서 팝할 때도 팝하고 나서도 해당 위치에 인형은 뽑은 것이므로 0으로 처리 해줬어야 했는데, 그렇게 하지 않고 있었다.
  // board[r][c] = 0; 구문을 break; 위로 옮기니 통과할 수 있었다.
  // 그럼 어제 통과 못한 이유도 같은 이유였을까 싶긴 한데, 꼭 그렇지는 않은 것 같다. 어제는 break 구문 위에서 처리해줬던 것 같다.
  // 아마도 어제 풀이는 포인터나 다른 부분에서 논리적으로 에러가 있던 것 같다.
/////////////////////////////////////////////////////////////
import java.util.*;

class Solution {
  public int solution(int[][] board, int[] moves) {
    int answer = 0;
    Stack<Integer> stack = new Stack<>();
    int n = board.length;
    int m = moves.length;
    int ss = 0;
    for (int i=0; i<m; i++) {
      int c = moves[i]-1;
      for (int r=0; r<n; r++) {
        if (board[r][c] != 0) {
          if (ss != 0 && (stack.peek() == board[r][c])) {
            stack.pop();
            ss -= 1;
            answer += 2;
          } else {
            stack.push(board[r][c]);
            ss += 1;
          }
          board[r][c] = 0;
          break;
        }
      }
    }
    return answer;
  }
}
