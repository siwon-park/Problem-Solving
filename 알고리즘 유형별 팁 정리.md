# 알고리즘 유형별 팁 정리

알고리즘 유형별 팁 정리

<br>

## 1. 너비 우선 탐색

너비 우선 탐색에서 큐에서 요소를 뽑을 때,

일반적으로 큐에 요소가 있는 동안 `while`문을 써서 뽑지만,

유형에 따라서는 큐의 크기만큼 뽑아야 하는 경우도 있다.

```java
// 일반적인 유형
while (!queue.isEmpty()) {
    queue.poll();
}

// 큐의 크기만큼 뽑을 때
while (!queue.isEmpty()) {
    int n = queue.size();
    for (int i = 0; i < n; i++) {
        queue.poll();
    }
}
```

<br>

## 2. 백트랙킹, 재귀

백트랙킹, 재귀의 함수 구현 및 호출부는 그 구조가 같음

- 예시1- 방문 체크를 먼저 한 다음에 dfs호출
  - 함수 밖에서 방분 체크 및 해제를 한다.

```java
// dfs 함수를 처음에 호출하기 위해 방문 체크를 확인한 다음 호출하였음
if (!visited[i]) {
    visited[i] = true; // 방문 체크
    dfs(i); // dfs 호출
    visited[i] = false; // 방문 체크 해제
}

// dfs 구현부에서도 마찬가지로 먼저 방문 체크를 확인한 다음 dfs를 재귀적으로 호출함
void dfs(int cur) {
    if (cur >= N) return;
    for (int i = 0; i < N; i++) {
        if (!visited[i]) {
            visited[i] = true; // 방문 체크
            dfs(i); // dfs 호출
            visited[i] = false; // 방문 체크 해제
        }
    }
}
```

- 예시2- dfs안에서 방문체크를 하는 경우
  - 함수 안에서 방문 체크 및 해제를 함
  - 이 때, 함수 안에서 방문 체크/해제는 먼저 호출된 함수의 인자에 대한 것임

```java
dfs(i); // dfs 호출(방문 체크를 하지 않고 함수부터 호출)

// dfs 구현부에서도 마찬가지로 함수를 재귀적으로 먼저 호출하고, 호출된 함수 밖에서 방문을 체크/해제함
void dfs(int cur) {
	if (cur >= N) return;
    visited[cur] = true; // 방문 체크
	for (int i = 0; i < N; i++) {
        dfs(i); // dfs 호출
    }
    visited[cur] = false; // 방문 체크 해제
}
```

<br>

## 3. 이분탐색

찾고자 하는 대상이나 범위에 의미를 부여하는 것이 가장 중요하다.

### 매개변수 탐색

매개 변수 탐색에서 찾고자 하는 값을 `while`문 안에 `for`문을 통해서 찾는 방법도 있지만,

```java
// 일반적으로 많이 사용하는 방법
while (s <= e) { // while문 안에서
    int mid = (s + e) / 2;
    int cnt = 0;
    for (int i = 0; i < N; i++) { // for문을 통해 원하는 값을 찾아나감
        cnt += (arr[i] % mid);
    }
    if (cnt > M) {
        s = mid + 1;
    	ans = mid;
    }
    else e = mid - 1;
}
```

다음과 같이 `for`문 안에 `while`문을 사용하여 찾을 수도 있다. (물론 위의 경우와 같은 문제가 아님을 유의!)

```java
for (int i = 0; i < N; i++) { // for 문 안에서
    int s = i;
    int e = N - 1;
    while (s <= e) { // while 문을 통해 값을 찾아나감
        int mid = (s + e) / 2;
        int blank = (arr[mid] - arr[i] + 1) - (mid - i + 1);
        if (blank <= p) {
            s = mid + 1;
            ans = Math.max(ans, p - blank + arr[mid] - arr[i] + 1);
        } else e = mid - 1;
    }
}
```

위에서 이런 차이가 발생한 것은 찾고자 하는 값이 무엇이냐에 따라 달라진 것이다.

`while`문 안에서 `for`문을 호출한 경우는 찾고자 하는 값이 전체를 기준으로 어떤 특정 최댓값 또는 최솟값이고,

`for`문 안에서 `while`문을 호출한 경우는 찾고자 하는 값이 단일값을 기준으로 어떤 특정 최댓값 또는 최솟값을 찾고자 하는 것이다.

<br>

## 4. 다익스트라

### 최단 거리 테이블

다익스트라에서 최단 거리 테이블을 어떻게 만드느냐가 중요하다.

문제에 따라서 특정 노드까지 가는데 비용 외에 다른 조건이 주어져 있다면, 일반적으로 2차원의 최단 거리 테이블을 생성하는 것을 고려해봐야 한다.

`distance[i][k] = cost`  => `i`번 노드로 가는데 `k`번의 조건을 수행하여 `cost`만큼 비용이 듦

그런데 경우에 따라서는 비용과 특정 조건이 주어지더라도 비용을 사용하지 않고 특정 조건만 사용하여 최단 거리 테이블을 만들기도 한다.

`distance[i] = k` => `i`번 노드로 가는데 `k`번의 조건을 수행하여 이동함

바로 위의 경우는 비용보다는 k번 이하의 동작으로 해당 노드에 갈 수 있는지 유무가 더 중요하기 때문에 최단 거리 테이블을 이렇게 구성한 것이다.

최단 거리 테이블을 통해 찾고자 하는 값과 그것을 사용하는 목적을 생각해보면 어떻게 구성하는 게 적합한지 나올 것이다.
