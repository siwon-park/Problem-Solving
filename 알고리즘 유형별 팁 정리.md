# 알고리즘 유형별 팁 정리

알고리즘 유형별 팁 정리

<br>

## 1. 너비 우선 탐색

너비 우선 탐색에서 큐에서 요소를 뽑을 때,

일반적으로 큐에 요소가 있는 동안 `while`문을 써서 뽑지만,

유형에 따라서는 큐의 크기만큼 뽑아야 하는 경우도 있다.

```java
// 일반적인 유형
while (!queue.isEmpty()) {
    queue.poll();
}

// 큐의 크기만큼 뽑을 때
while (!queue.isEmpty()) {
    int n = queue.size();
    for (int i = 0; i < n; i++) {
        queue.poll();
    }
}
```

<br>

## 2. 백트랙킹, 재귀

백트랙킹, 재귀의 함수 구현 및 호출부는 그 구조가 같음

- 예시1- 방문 체크를 먼저 한 다음에 dfs호출
  - 함수 밖에서 방분 체크 및 해제를 한다.

```java
// dfs 함수를 처음에 호출하기 위해 방문 체크를 확인한 다음 호출하였음
if (!visited[i]) {
    visited[i] = true; // 방문 체크
    dfs(i); // dfs 호출
    visited[i] = false; // 방문 체크 해제
}

// dfs 구현부에서도 마찬가지로 먼저 방문 체크를 확인한 다음 dfs를 재귀적으로 호출함
void dfs(int cur) {
    if (cur >= N) return;
    for (int i = 0; i < N; i++) {
        if (!visited[i]) {
            visited[i] = true; // 방문 체크
            dfs(i); // dfs 호출
            visited[i] = false; // 방문 체크 해제
        }
    }
}
```

- 예시2- dfs안에서 방문체크를 하는 경우
  - 함수 안에서 방문 체크 및 해제를 함
  - 이 때, 함수 안에서 방문 체크/해제는 먼저 호출된 함수의 인자에 대한 것임

```java
dfs(i); // dfs 호출(방문 체크를 하지 않고 함수부터 호출)

// dfs 구현부에서도 마찬가지로 함수를 재귀적으로 먼저 호출하고, 호출된 함수 밖에서 방문을 체크/해제함
void dfs(int cur) {
	if (cur >= N) return;
    visited[cur] = true; // 방문 체크
	for (int i = 0; i < N; i++) {
        dfs(i); // dfs 호출
    }
    visited[cur] = false; // 방문 체크 해제
}
```

<br>

## 3. 이분탐색

찾고자 하는 대상이나 범위에 의미를 부여하는 것이 가장 중요하다.

### 매개변수 탐색

매개 변수 탐색에서 찾고자 하는 값을 `while`문 안에 `for`문을 통해서 찾는 방법도 있지만,

```java
// 일반적으로 많이 사용하는 방법
while (s <= e) { // while문 안에서
    int mid = (s + e) / 2;
    int cnt = 0;
    for (int i = 0; i < N; i++) { // for문을 통해 원하는 값을 찾아나감
        cnt += (arr[i] % mid);
    }
    if (cnt > M) {
        s = mid + 1;
    	ans = mid;
    }
    else e = mid - 1;
}
```

다음과 같이 `for`문 안에 `while`문을 사용하여 찾을 수도 있다. (물론 위의 경우와 같은 문제가 아님을 유의!)

```java
for (int i = 0; i < N; i++) { // for 문 안에서
    int s = i;
    int e = N - 1;
    while (s <= e) { // while 문을 통해 값을 찾아나감
        int mid = (s + e) / 2;
        int blank = (arr[mid] - arr[i] + 1) - (mid - i + 1);
        if (blank <= p) {
            s = mid + 1;
            ans = Math.max(ans, p - blank + arr[mid] - arr[i] + 1);
        } else e = mid - 1;
    }
}
```

위에서 이런 차이가 발생한 것은 찾고자 하는 값이 무엇이냐에 따라 달라진 것이다.

`while`문 안에서 `for`문을 호출한 경우는 찾고자 하는 값이 전체를 기준으로 어떤 특정 최댓값 또는 최솟값이고,

`for`문 안에서 `while`문을 호출한 경우는 찾고자 하는 값이 단일값을 기준으로 어떤 특정 최댓값 또는 최솟값을 찾고자 하는 것이다.
